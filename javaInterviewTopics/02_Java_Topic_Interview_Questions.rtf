{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 HelveticaNeue;
\f3\fnil\fcharset0 HelveticaNeue-Bold;\f4\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;\red14\green79\blue181;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0\c90196;\cssrgb\c0\c0\c0\c7843;\cssrgb\c3922\c40000\c76078;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid101\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid201\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh14120\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs36 \cf0 Java 8 \
\
Java Pattern & Mathcher\
\
Matcher class\
matches() /find() / group()[return the matched subsequnce] /groupcount()\
\
PatternClass\
Compile /matcher /matches / split / pattern\
\
Patter.compile(\'93abc\'94\
String s[] = p.matches(inputString);\
\
For grouping u need to define pattern in form of grouping regex & the do p.matcher.find() & then u can get group if present \
\
\
\
Weak hashMap is a implementation of the map where keys that store only weak references to its key. Storing only weak references allows a key value pair  to be Gargage collected when the key is not refreshed outside\
\
Identity Hashmat\
Works on references equality & not on object equality\
\
Enum map\
Special implementation of map for enumerations type\
ENumMap<Enum,Vakue> = new EnumNMap<Month.class>()\
\
Heavy weight thread\
Means amount of context associated with a thread & consequently amount if time it take to do context switch\
\
Usually kernel level Thedas are heavy weights it takes lotto of hardware registers kernel stacks etc switches.\
\
\
How does priority queue & tree map work internally \
\
\
If 2 interface has same method defined as default & when both interface is implemented in 1 clsss \
Then if no implementation provide then compile error but if implementation is override then it fine ( we can either of interface method as well I1.super.getgreeting ) \
\
\
Finalise method\
\
This method is called by garbage collector just before doing cleaning. If incase any resources are used by object it is advisable to free those resources in finalise method \
\
Concurrent modification error\
\
When collection is changed during iteration\'85\
Only way to avoid..use iterator method remove ( & when its happening collection sue nt change externally either by directly removing or by removing through different iterator at the same time )\
\
\
Exception & Errors\
Exception & error bth are subclasses of the trouble class..\
\
Creating an exception object is nt expensive but the operation to fill native call to fillInstackTrace method which walks through the call stack & collect all required information to build a stack trace : classes methods, lines, number..\
Most of throwable constructors implicitly cal fillinStackTrace. & that why creating exception is slow come from. \
We can make exception lightweight wither by not using fillintrace while initialising throwable or overriding fillinStacktrace.\
\
Now what about throwing an exception \
In fact it depends on where a thrown exception is caught if it is caught in same method then how is as fast & simple as goto\
\
However if a catch block is somewhere deeper in the stack then jam need to unwind the stack frames And this can take significantly longer, it can take longer if sync block & method are involved  \
\
Checked exception & Unchecked exception:\
\
U can decide \
But if a method is likely to fail & chances of failure are more than 50% it sue throw checked exception to ensure alternate processing incase it failed. Another thought is programming errors should be unchecked & derive from RunTimeException\
\
& when u handle it via checked exception it makes your code ugly.\
\
\
\
Eception can be handled but error that is nt caught by user program \
\
JDBC\
\
Prepared statements are precompiled & hence has better performance \
Callable statements is sued to execute stored procedures\
\
\
Loggers\'92\
\
For logging we can use log4J framework\
\
It has 3 component :\
Logger\
Appender\
Layout\
\
Logger is the class in log4j package, we have to initialise the logger object for each java class & we use logger method to generate log statements \
\
It has static method for creating logger object & it has below method:\
\
Info/debug/warn/fatal/error\
\
Appender is used to write messages into a file or DB or SMPT\
\
Jdbc appenders\
Fileappender\
Smtpappenders\
\
\
Layout\
Used to define the formatting in which logs will print in a repo.\
\
Logging confirmation are defined in log4j.preoperteis\
\
Log4j.rootLogger=INFO , file ,stdout\
//appender info file based\
Log4j.appender.file.*(FILE/MAXFILESIZE/MaxBackupIndex,layput,layputConversionPatter\
\
//apender to console\
Log4j.appender.stdout=(Target/layput)\
\
\
Kind of relationship\
\
Is -a ( inheritance )\
Has -a ( composition )\
Uses -a ( aggregation )\
\
Example : House is a building\
           House has a room\
             House has an occupant\
\
\
Agregation & composition\
Aggregation implies child can exist without parent as well like employe can exist without bank \
\
But in case of composition child cannot exist without parent like heart without body\
\
\
\
Count occurence of character in String eg i:\
\
1) use Instream.rangeClose().forEach\'85.\
2) s.chars().filter().count();  //charStream in form if IntStream with Asci value\
\
Count occurrence of every chapter in String\
3) Arrays.stream(s.split(\'93\'94)).map(String::toLowerCase).collect(groupingBy(s->s,HashMap::new,Collectors.counting)\
If there is any particular number then we can use filter & use count() directly\
\
\
Better example of grouping by :\
\
Person ( last name & city ) \
Groupie on basis of city & accumulate all last names together\
By default HashMap is used for collection but if u need any other implementation like LinkedinhashMap or TreeMap then u can define in between first arg ( classifier ) & last arg ( collector downstream) \
\
//collect all person(full object) by city\
Persons.stream().collect(groupingby(Person::getCity,toList())\
Return Map<City,List<Person>\
If unique entry & use toSet() & equals HashCode need to be implemented\
\
\
//collect All person but only last name by city \
\
Persons.stream().collect( groupingby(Person::getCity, mapping(Person::getLastName,toList());\
Return Map<City,List<String>\
 **mapping( mapper , downStream) \'97> map & then put into downstream collector\
\
//If want to store result in sorted order then use TreeMap\
\
\
Persons.stream().groupingBy(Person::getCity,TreeMap::new,mapping(Person::getLastname,toList());\
\
//if you want to store only lastCity name with longest last name \
\
Comparator<String. byLength = Comparator.comparing(String::length);\
Map<City,String> longestLastnameByCity = people.stream().collect(groupingBy(Person::city,reducing(\'93\'94,Person::getLastName,BinaryOperator.maxby(byLength));\
\
\
getMaximum height person from all city\
\
heightComparator = comperator.comparing(Person::getHeight)\
Map<City,Optional<Person>. Map = persons.stream().collect(groupingBy(Person::city, reducing(BinaryOperator.maxBy(heightComperator));\
\
\
\
\
\
\
\
\
Java Time: java time:\
\
Older java.util.Date & java.util.calendar ( thread safety issue & not much api to support & zone support is less ) mostly please used coda lib\
\
Java 8 :\
LocalDate LocalTime LoclDateTime\
LocalDate ) Iso format ( yyyy-MM-DD )\
LocalDate.now/of/parse\
\
LocalTime ( represent time without date )\
LocalDateTime represent date + time.\
ZonedDateTime \
\
Period : quantity of time in in terms years months & days \
\
Duration class represent a quantity of time terms of seconds & nanseconds\
\
Instant \
Epic\
\
\
\
Java data types:\
\
Byte 1 byte\
Int  4 byte\
Long 8 byte\
Float 4 byte\
Double 8 byte\
Char 2 byte\
\
Sql\
varchar(n) n byte + 2. ( 8168 CHAR ) ( 4000 bytes ) \
NUMBER 21 Byte\
LONG 2^31 -1 bytes \
ROWID 10 bytes \
Date 7 bytes\
CLOB 4 gigabyte\
Blob 4 gigabyte\
TImeStamp 11 byte \
\
CHAR 2000 byte \
\
Sql :\
\
CLOB character Large data \
BLOB binary large object .\
\
\
\
Java Reusability \
Using generics:\
\
\
\
\
Java serialisation\
When marker interface is implemented in parent class , child class will automatically inherit it & JVM will take care serialisation\
If any object is composed under class then either it has to be implement serialisation or it sue be marked as transient or it sad be null\
\
If parent class is not marked with serialisation but class is marked with and if you want to save/serialized super variable then it suddenly be done via readObject & iptilize them back in writeObject method. & if not handled it will be intilized with default value & default constructor must be present & if not present it will error.\
\
\
\
There is another interface called externizable which is used for custom serialisation and only custom fields will be serialised  & when deserialised it sud be in same order .. this same behaviour can be achieve via transient keyword but serialisation will heavy since even though it transit variable will be written with default value in file/network\
\
===================================================================================\
\
Java streams\
\
Streams is very helpful in funtional programming & you won\'92t impact source collection.\
Stream also can use multi core to parallel computing ..\
We can have multi intermediate operation which has stateful & stateless operation \
Stateful ( like sorted which need all output from previous step )\
Stateless ( like map , filter which work like all intermediate operation will happen on each element till terminal operation is called )\
Stream has concat & merge to merge multiple streams\
\
\
Functional interface \
Has only single unimplemented method. But can have default & static methods\
\
Java HashMap\
\
\
Get operation\
\
table[hash] \'97> Entry ( key , value , hash , Entry next )\
\
Key.hash == table[hash].hash && (table[hash].key == key || table[hash].key.equsls(key) )\
\
\
Put operation\
\
Key.hash == table[hash].hash && (table[hash].key == key || table[hash].key.equsls(key) )\
table[hash].value will be replaced \
\
Else new entry will be inserted \
\
\
\
\
\
Java Design patterns\
=============================================\
https://refactoring.guru/design-patterns/structural-patterns\
\
\
============================================================================\
JAVA Generics:\
\
\
The Need for Generics : Type Safety : Generics make errors to appear compile time than at run time \
Let's imagine a scenario where we want to create a list in Java to store Integer; we can be tempted to write:\
\
List list = new LinkedList();\
list.add(new Integer(1)); \
Integer i = list.iterator().next();\
Surprisingly, the compiler will complain about the last line. It doesn't know what data type is returned. The compiler will require an explicit casting:\
\
Integer i = (Integer) list.iterator.next();\
There is no contract that could guarantee that the return type of the list is an Integer. The defined list could hold any object. We only know that we are retrieving a list by inspecting the context. When looking at types, it can only guarantee that it is an Object, thus requires an explicit cast to ensure that the type is safe.\
\
This cast can be annoying, we know that the data type in this list is an Integer. The cast is also cluttering our code. It can cause type-related runtime errors if a programmer makes a mistake with the explicit casting.\
\
It would be much easier if programmers could express their intention of using specific types and the compiler can ensure the correctness of such type. This is the core idea behind generics.\
\
Let's modify the first line of the previous code snippet to:\
\
List<Integer> list = new LinkedList<>();\
By adding the diamond operator <> containing the type, we narrow the specialization of this list only to Integer type i.e. we specify the type that will be held inside the list. The compiler can enforce the type at compile time.\
\
Implementing generic algorithms: By using generics, we can implement algorithms that work on different types of objects and at the same they are type safe too.\
\
Generic methods have a type parameter\
Type parameters can be bounded \
Code Reuse: We can write a method/class/interface once and use for any type we want.\
\
3.1. Bounded Generics\
As mentioned before, type parameters can be bounded. Bounded means \'93restricted\'93, we can restrict types that can be accepted by a method.\
\
For example, we can specify that a method accepts a type and all its subclasses (upper bound) or a type all its superclasses (lower bound).\
\
3.2. Multiple Bounds\
A type can also have multiple upper bounds as follows:\
\
1\
<T extends Number & Comparable>\
\
\
=======================================================================================================================================\
\
\
\
Concurrency:\
\
1) BlockingQueue & Its implmentation\
Ans ) this api is thread safe & handle producer consumer problem as well\
\
\
=======================================================================================================================================\
\
\
\
GarBage Collection:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\b \cf0 https://www.cubrid.org/blog/3826456
\f0\b0 \
\
GC Tuning\
Garbage colection tuning\
Examples of Tuning\
See the result of \
jstat \'96gcutil.\
S0 S1 E O P YGC YGCT FGC FGCT GCT\
12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993\
\
GC Type	GC Execution Times	GC Execution Time	Average\
Minor GC	54	2.047	37 s\
Full GC	5	6.946	1,389 ms\
\
First, you should check how the memory is used before starting GC tuning. Use the jstat \'96gccapacity option to check the memory usage. The result checked from this server is as follows.\
\
detailed way than jstat, the -verbosegc \
\
newRatio will make oldgen bigger comapre to youngen & so can have less majorGC\
\
\
Options to Be Checked for GC Tuning.\
\
Classification	Option	Description\
Heap area size	-Xms	Heap area size when starting JVM\
 	-Xmx	Maximum heap area size\
New area size	-XX:NewRatio	Ratio of New area and Old area\
 	-XX:NewSize	New area size\
 	-XX:SurvivorRatio	Ratio of Eden area and Survivor area\
	\
Setting Memory Size\
The following shows the relationship between the memory size, the number of GC execution, and the GC execution time.\
\
\
Large memory size\
decreases the number of GC executions.\
increases the GC execution time.\
Small memory size\
decreases the GC execution time.\
increases the number of GC executions.\
\
\
Types of Garbage Collectors:\
\
Serial Garbage Collector\
Parallel Garbage Collector\
CMS Garbage Collector\
G1 Garbage Collector\
\
Serial Garbage Collector:\
A single thread is used for garbage collection and it will freeze all the application threads while performing GC (Garbage Collection).\
\
Parallel Garbage Collection:\
It uses multiple threads for garbage collection, this also freezes all the application threads while performing GC\
\
CMS Garbage Collector:\
Concurrent Marksweep Garbage collector, CMS scans the heap mark and mark the instances that requires to be removed and then will clear the marked instances\
\
G1 Garbage Collector:\
This will divide the heap memory into equal parts and will perform the GC on the part which has lesser live data.\
\
What is the difference between CMS and G1GC?\
\
Both are designed to minimize long pause when performing GC. But G1GC is used for larger heap that is more than 4GB.\
\
CMS \'96 Uses one or more thread to scan the memory periodically and remove the unused objects, where pause time is minimal but cpu time is more\
\
G1GC \'96 It divides the memory into equal parts and cleans old generation by copy from one part to another\
\
\
GarbageCollectors work on live object which are accessibly from GC roots:\
\
1) Classes loaded by system class loader\
2)Live threads & referenced variables\
3) Local variables & params of JNI method\
4)Global JNI reference\
5)Object used as monitor for sync\
6) Object help from garbage collection by JVM for its purpose\
\
Very nice link must visit\
https://www.freecodecamp.org/news/garbage-collection-in-java-what-is-gc-and-how-it-works-in-the-jvm/\
\
\
\
=======================================================================================================================================\
\
\
Java Memory Model\
\
--Memory Allocation In Java ( how object allocation happens in java )\
http://tutorials.jenkov.com/java-concurrency/java-memory-model.html\
\
Java Memory Model - Visibility problem, fixing with volatile variable\
https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/java-memory-model.html?1\
https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/visibility-volatile.html\
\
Info:\
\
Heap & Meta space\
\
heap is divided into young gen & Old gen\
and young gen is divided into eden & 2 surviors sapce\
\
\
heap store actual objects, all thread can access all objects in the heap if they have refernce to it.\
\
Stack local varriables & functional call is stored..store refernce to object which is created in heap.only owner thread can acces the variable.\
\
Young generation is the space where every new object is created. \
\
Important Points:\
Most of the newly created objects are located in the Eden memory space.\
\
When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.\
\
Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.\
\
Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually, By setting an age for the young generation objects before they become eligible to promote to Old generation.\
\
Perm Gen/Metaspace:\
\
PermGen space:\
Stores class related data, and is used to keep information for loaded classes and few other advanced features like StringPool.\
\
MetaSpace: (From 1.8, instead of perm gen)\
\
Are part of native memory \'96 OS level\
Metaspace by default increases its size , To the limit of OS, while PermGen always has a fixed maximum size.\
No more out of memory error\
We can set the size of metaspace and also it increases automatically, but permgen wont increase by itself\
Garbage collection of the dead classes and classloaders is triggered once the class metadata usage reaches the MaxMetaspaceSize.\
So where does static variables and static classes are stored? Is it heap or Permgen?\
\
Since the heap has actual objects, static variables and static classes are stored in Permgen / Metaspace.\
\
T\
\
\
=======================================================================================================================================\
\
\
Java Collection API\
\
\
\
=======================================================================================================================================\
\
\
\
Java Interview Questions:\
\
Java8 features\
\
1_ StreamAPIs\
2) Date & time Apis\
3) Optional\
4) lambdas\
5) methodRefernce\
6) default method \
7 functional interfaces /SAM single abstract method\
\
Q1) why java is platform independent.?\
Ans : since Java sources classes get converted to byte code by java compiler & this byte can be run on platform\
Since JVM \uc0\u8203 executes the Java bytecode which is platform-independent, Java is platform-independent.\
Working of Java Program:\
\
Java Program --Java compiler ---> java ByteCode(.class file ) ---JVM--->machineCode---CPU--> output\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Q2 ) JVM/ JDK /JRE\
Ans\
JVM\
JVM (Java Virtual Machine) is an abstract machine. It is called a virtual machine because it doesn't physically exist. It is a specification that provides a runtime environment in which Java bytecode can be executed. It can also run those programs which are written in other languages and compiled to Java bytecode.\
JVM, JRE, and JDK are platform dependent because the configuration of each OS is different from each other. However, Java is platform independent.\
\
JRE (Java Runtime Environment) is a software package that provides Java class libraries, Java Virtual Machine (JVM), and other components that are required to run Java applications.\
\
JDK (Java Development Kit) is a software development kit required to develop applications in Java. When you download JDK, JRE is also downloaded with it.\
\
In addition to JRE, JDK also contains a number of development tools (compilers, JavaDoc, Java Debugger, etc).\
\
JDK = JRE + compilers + debugggers + JavaDoc\
JRE = JVM + Class libraries + rt jars\
JVM  == it converts bytercode to machine code and run it \
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q3 ) what are the components of JVM/JVM architecture ??\
\
Ans: JVM consist of 5- main component\
\
A) Class Loading & linking initialisation \
2) Memory allocation & management\
3) Execution engine ( compiler & Jit )\
4) Katie method calls & initialisation\
5) java collection Api\
Provides runtime environment for your app\
\
\
basic:\
https://www.programiz.com/java-programming/jvm-jre-jdk\
\
Detailed:\
https://dzone.com/articles/jvm-architecture-explained\
https://dzone.com/articles/a-detailed-breakdown-of-the-jvm\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q4) How does the JVM work ??/\
\
Q4) java Memory model\
Ans) covered above \
https://dzone.com/articles/java-memory-management\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q5) Jvm provide & Class ladders type\
Ans) Bootstrapped classloader\
SystemClass/extension Classloader\
Applciation class lander\
\
BootStrap ClassLoader \'96 Responsible for loading classes from the bootstrap classpath, nothing but rt.jar. Highest priority will be given to this loader.\
Extension ClassLoader \'96 Responsible for loading classes which are inside the ext folder (jre\\lib).\
Application ClassLoader \'96Responsible for loading Application Level Classpath, path mentioned Environment Variable, etc.\
The above ClassLoaders will follow Delegation Hierarchy Algorithm while loading the class files.\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
Q5.1) What is internals for JVM loading linking & initialisation\
Ans )\
ClassLoader Subsystem\
Runtime Data Area\
Execution Engine\
1. ClassLoader Subsystem\
Java's dynamic class loading functionality is handled by the ClassLoader subsystem. It loads, links. and initializes the class file when it refers to a class for the first time at runtime, not compile time.\
\
1.1 Loading\
Classes will be loaded by this component. BootStrap ClassLoader, Extension ClassLoader, and Application ClassLoader are the three ClassLoaders that will help in achieving it.\
\
\
1.2 Linking\
Verify \'96 Bytecode verifier will verify whether the generated bytecode is proper or not if verification fails we will get the verification error.\
Prepare \'96 For all static variables memory will be allocated and assigned with default values.\
Resolve \'96 All symbolic memory references are replaced with the original references from Method Area.\
1.3 Initialization\
This is the final phase of ClassLoading; here, all static variables will be assigned with the original values, and the static block will be executed.\
\
JVM internal\
\
Https://blog.jamesdbloom.com/JVMInternals.html\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q6) Custom ClassLoader\
Ans) we can create custom class loader by extending classlaoder interface/abstract provide implemtnatin for method\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
Q7 ) Java principle/OOPS content\
-JAVA PRINCIPLES\
--Abstraction\
--Polymorphism\
---static/compile type binding, overloading\
---dynamic/runtime binding, overriding \
--Enacpsulation\
--Inheritace ( Is a )\
--Composition ( has a )\
\
Defined in detail in below info section\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q8 ) java collection Api & thread safe collection\
Ans ) ArrayList/LinkedList/Stack/hashMap/TreeMap/TreeSet/Set/SyncronozedMap/CopyOnwriteArray/Trie\
Iterators( failsafe/failfast)/\
Comparator/comperable\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q9 ) generics(wild card in genrics (upperbound/read)/(lowerbound/insert)/(type/only sout)\
) defined above in info section\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q10 ) happens before relations ship\
ANs) https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html\
\
It simple means once the value is written to variable all the corresponding read on that variable will read latest value & not from the\
Cache\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q11) Cloning interface/ deep cloning / shallow cloning\
Ans deep cloning clone all nested classes & their members whereas shall will clone one till 1 level parent\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q12 ) Serialisation & Externalisation  marker interface ) & SerialUUID\
Ans)\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Q12 ) synchronised, volatile & Atomic \
\
Synchronizing the shared data access across threads achieves two things:\
Mutual exclusion of two thread execution over synchronized block. This achieves atomicity. A threads is not able to see incomplete writes (involving multiple variables) of other threads.\
Flushing of local thread memory to main memory at the time when the lock is released (at the end of synchronized block).\
\
Fixing visibility problem with volatile variable\
Java - Volatile reference object and its member fields visibility\
\
https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/java-memory-model.html?1\
https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/visibility-volatile.html\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q13) Difference in interface & abstract classes\
Abstract class has state whereas interface does not have \
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q14) create deadlock\
\
Create 2 runnable which contains 2 object lock but \
\
Create bifunction which take 2 locks & return a ruubaleh task\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q15 ) create race condition\
\
Create a runnable task & share a variable shared between 2 threads\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q16) producer-consumer problem ( wait notify )\
\
Print even and odd\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q17) what is class/object level locking\
\
Object level locking\'85\
\
sync( object/this)\
\
T1 \'97> o1-> m1()//sync(this)\
T2 -> o2-> m1()//sync(this)\
T3 -> o2 -> m1()//sync(this) blocked\
T4 -> o2 -> m2()//sync(this) blocked\
T5 -> o2 -> m3() // no sync paralle \
\
Class level lock\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q18 ) Executer Service & its internal implementation\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q19) Fork Join working / Recursive task\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q20 ) Runnable & callable & computable difference & examples & Futures\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q21 ) Thread Join , cyclic barrier & countDown Latch \
\
Barrier is usable ( eg biker and need to meet at barrier before starting for new barrier )\
LatchDown ( its like water has arrived but min quantity food is not arrived)\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q22) Code to write addition of n number using multiple threads\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q23 ) Create Immutable classes\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q24 ) Synchronised , volatile & Atomic numbers difference\
\
Volatile only supports memory visibility or memory barrier \
Atomic support atomicity of operations & also guarantee memory visibility for that particular variable\
Where synchronised u able to achieve atomicity for complex tasks by making it mutually exclusive also \
Well I have read multiple places all writes under thread write under sync block will flushed to memory & follow happens before relationship\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
Q25) double locking check\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
Q26 ) Different the of exception & try with resource which java cerise & example\
\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
Q27 ) what is static & dynamic binding\
Ans )\
\
Static Binding (also known as Early Binding compile timw).\
determine at compile time \
method overloading\
The binding of overloaded methods is static\
binding of private, static and final methods always happen at compile time since these methods cannot be overridden.\
When the method overriding is actually happening and the reference of parent type is assigned to the object of child class type then such binding is resolved during runtime\
\
\
Dynamic Binding (also known as Late Binding).\
binding of overridden methods is dynamic.\
  dynamic binding happens at runtime.\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q28 ) Java Locks\
Ans ) \
http://tutorials.jenkov.com/java-concurrency/synchronized.html\
http://tutorials.jenkov.com/java-concurrency/read-write-locks.html\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q29 ) access modifiers\
\
	Class	Package	Subclass (same pkg) Subclass(diff pkg) World\
public			+		+		+		+					+\
protected		+		+		+		+	\
no modifier		+		+		+		\
private			+	\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q30 ) How you can create try with resource type resource ??\
Ans ) u can create resource/Ytility extending AutoClosable\
In java 7, we have a new super interface java.lang.AutoCloseable. This interface have one method:\
\
void close() throws Exception;\
When we open any such AutoCloseable resource in special try-with-resource block, immediately after finishing the try block, JVM calls this close() method on all resources initialized in \'93try()\'94 block.\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q31) Exception ( checked vs Unchecked ) & do order matter while defining exception in catch block ?\
Ans )\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q32 ) can we error in static block ?\
\
No it will fail saying Jim cannot start normally\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q32 ) how errors can be throw ? Trow or throws keyword ?\
\
Throw is sued to manually throw error from catch bock & throws is defined at method level & caller need to handle the error explicitly\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q33 ) different between treeset & treemap\
https://www.geeksforgeeks.org/difference-between-treemap-and-treeset-in-java/\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Q34 Iterators\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf0 https://www.baeldung.com/java-iterator\
https://www.baeldung.com/java-fail-safe-vs-fail-fast-iterator\
\
ListIterator \
3.1. hasPrevious() and previous()\
ListIterator can be used for backward traversal so it provides equivalents of hasNext() and next():\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs36 \cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf0 \
\
\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs36 \cf0 =======================================================================================================================================\
\
Java Locks Implementation:\
\
\
public class ReadWriteLock\{\
\
  private int readers       = 0;\
  private int writers       = 0;\
  private int writeRequests = 0;\
\
  public synchronised void lockRead() throws InterruptedException\{\
    while(writers > 0 || writeRequests > 0)\{\
      wait();\
    \}\
    readers++;\
  \}\
\
  public synchronised void unlockRead()\{\
    readers--;\
    notifyAll();\
  \}\
\
  public synchronised void lockWrite() throws InterruptedException\{\
    writeRequests++;\
\
    while(readers > 0 || writers > 0)\{\
      wait();\
    \}\
    writeRequests--;\
    writers++;\
  \}\
\
  public synchronised void unlockWrite() throws InterruptedException\{\
    writers--;\
    notifyAll();\
  \}\
\}\
\
-------------------\
\
public class ReadWriteLock\{\
\
  private Map<Thread, Integer> readingThreads =\
      new HashMap<Thread, Integer>();\
\
  private int writers        = 0;\
  private int writeRequests  = 0;\
\
  public synchronized void lockRead() throws InterruptedException\{\
    Thread callingThread = Thread.currentThread();\
    while(! canGrantReadAccess(callingThread))\{\
      wait();                                                                   \
    \}\
\
    readingThreads.put(callingThread,\
       (getAccessCount(callingThread) + 1));\
  \}\
\
\
  public synchronized void unlockRead()\{\
    Thread callingThread = Thread.currentThread();\
    int accessCount = getAccessCount(callingThread);\
    if(accessCount == 1)\{ readingThreads.remove(callingThread); \}\
    else \{ readingThreads.put(callingThread, (accessCount -1)); \}\
    notifyAll();\
  \}\
\
\
  private boolean canGrantReadAccess(Thread callingThread)\{\
    if(writers > 0)            return false;\
    if(isReader(callingThread) return true;\
    if(writeRequests > 0)      return false;\
    return true;\
  \}\
\
  private int getReadAccessCount(Thread callingThread)\{\
    Integer accessCount = readingThreads.get(callingThread);\
    if(accessCount == null) return 0;\
    return accessCount.intValue();\
  \}\
\
  private boolean isReader(Thread callingThread)\{\
    return readingThreads.get(callingThread) != null;\
  \}\
\
\}\
\
=======================================================================================================================================\
\
-JAVA PRINCIPLES\
\
\
--Abstraction\
--Polymorphism\
--Enacpsulation\
--Inheritace ( Is a )\
--Composition ( has a )\
\
Abstraction is one of the key concepts of object-oriented programming (OOP) languages. \
Its main goal is to handle complexity by hiding unnecessary details from the user\
\
Hiding the complex implementation\
eg:  car is viewed as a car rather than its individual components.\
\
Java Polymorphism\
Polymorphism means "many forms", and it occurs when we have many classes that are related to each other by inheritance.\
 Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. \
 \
 \
 \
Encapsulation \
 \
Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.\
\
Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. \
In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.\
\
To achieve encapsulation in Java \uc0\u8722 \
\
Declare the variables of a class as private.\
\
Provide public setter and getter methods to modify and view the variables values.\
\
Benefits of Encapsulation\
The fields of a class can be made read-only or write-only.\
\
A class can have total control over what is stored in its fields.\
\
\
Encapsulation is data hiding(information hiding) while Abstraction is detailed hiding(implementation hiding).\
\
\
While encapsulation groups together data and methods that act upon the data, data abstraction deal with exposing the interface to the user and hiding the details of implementation.\
\
=======================================================================================================================================\
\
\
Java CompletableFuture \
\
\pard\pardeftab720\li1120\fi-1120\sa80\partightenfactor0

\f2\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
Completable future\
run in different thread then main app and use Global Fork.Join Pool\
\
\
Option 1 :\
Run a task which wont return anything & this will run totally indepently...!!\
where in callable one since either we wud be using executer or we are using thead to run so main app must wait for it completion...\
eg:CompletableFuture.runAsync()  --> this will return void\
\
\
Option 2:\
completable future return future then use CompletableFuture.supplyAsync(() which will return the value afer it execution\
& if you do completablefututre.get //call will blocked...\
\
\
option 3:\
Ypu want to run multiple operation one after other then u can chain in completable future...\
CompletableFuture\
--thenApply ( when one CF is dpende on other & want to return something..\
--then Accept ( will accept input from another CF but wont return anythung\
--thenRun ( will run independetly once parent CF copleted & wont return anything )\
\
\
if you want to combine something over another CF Th use can\
\
incase of depdndent tasks\
--Composeof of CF this will chain the multiple CFs one after other & will pass then  result to pne another in order..\
\
--if your 2 tasks are idnependent & 3rd depends upon first 2 the we can use combineOf..\
\
      System.out.println("Calculating BMI.");\
        CompletableFuture<Double> combinedFuture = weightInKgFuture\
                .thenCombine(heightInCmFuture, (weightInKg, heightInCm) -> \{\
                    Double heightInMeter = heightInCm/100;\
                    return weightInKg/(heightInMeter*heightInMeter);\
                \});\
\
\
\
---CFs Allof & AnyOFF...\
if you have multiple jobs but u need output from any one then ucase use anyOf\
        CompletableFuture<Object> anyOfFuture = CompletableFuture.anyOf(future1, future2, future3);\
\
\
\pard\pardeftab720\li1120\fi-1120\sa80\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://www.callicoder.com/java-8-completablefuture-tutorial/"}}{\fldrslt 
\f3\b \cf4 https://www.callicoder.com/java-8-completablefuture-tutorial/}}
\f0\fs36 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\
=======================================================================================================================================\
\
\
\
Java Files:\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls1\ilvl0
\f2\fs28 \cf2 \cb3 		\expnd0\expndtw0\kerning0
nputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
OutputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Above classes deal with byte arrays\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Subclasses for above 2 classes are :\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--InputStream(Base Class)\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--FileInputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
The Java FileInputStream class, java.io.FileInputStream, makes it possible to read the contents of a file as a stream of bytes.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
FileInputStream fileInputStream = new FileInputStream("c:\\\\data\\\\input-text.txt");\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Example:--\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
byte[] data      = new byte[1024];\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int    bytesRead = fileInputStream.read(data, 0, data.length);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
while(bytesRead != -1)\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
  doSomethingWithData(data, bytesRead);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
  bytesRead = fileInputStream.read(data, 0, data.length);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--BufferedInputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Buffer version of InputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
eg:\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int bufferSize = 8 * 1024;\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
BufferedInputStream bufferedInputStream = new BufferedInputStream(\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                      new FileInputStream("c:\\\\data\\\\input-file.txt"),\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                      bufferSize\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
ByteArray\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
the ByteArrayInputStream class can turn a byte array into an InputStream.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
eg:\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
byte[] bytes = ... //get byte array from somewhere.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--DataInputStream:\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
The Java DataInputStream class, java.io.DataInputStream, enables you to read Java primitives (int, float, long etc.) from an InputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
instead of only raw bytes.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--ObjectInputStream ( enables you to read java object from InputStream)\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Convert InputStream to Object\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
eg:\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
      InputStream is = new ByteArrayInputStream(bytes);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
      try (ObjectInputStream ois = new ObjectInputStream(is)) \{\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
          return ois.readObject();\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
--Additonal Inout/op streams\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 Piped/Filter/Pushback/\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 ====================================================\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 OutputStream -->\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 A Java OutputStream is typically connected to some data destination - as mentioned in the Java IO Overview,\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 like a file, network connection, pipe, memory buffer etc.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 FileOutputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 makes it possible to write a file as a stream of bytes\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 OutputStream output = new FileOutputStream("c:\\\\data\\\\output-text.txt");\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 while(moreData) \{\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
   int data = getMoreData();\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
   output.write(data);\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 \}\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 output.close();\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 ByteArrayOutputStream\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 byte[] bytes = byteArrayOutputStream.toByteArray();\
\pard\tx566\pardeftab720\sa80\partightenfactor0
\cf2 \
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 BufferedOutputStream:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 int bufferSize = 8 * 1024;\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 OutputStream output = new BufferedOutputStream(\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                       new FileOutputStream("c:\\\\data\\\\output-file.txt"),\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                           bufferSize\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 );\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 byte bytes =  new byte[]\{1,2,3,4,5\};\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 outputStream.write(bytes);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 ObjectOutputStream\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Enables you to write Java objects to an OutputStream instead of just raw bytes.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
ObjectOutputStream objectOutputStream =\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    new ObjectOutputStream(new FileOutputStream("object.data"));\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
MyClass object = new MyClass();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
output.writeObject(object);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
output.close();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
All the above classes mostly dealing with bytes & bute array directly...\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Java Reader\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Java Writer\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
java Reader ( base class )\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
t is character based rather than byte based\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
eg:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
InputStreameader:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
wraps a Java InputStream, thereby turning the byte based InputStream into a character based Reader.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
InputStream inputStream       = new FileInputStream("c:\\\\data\\\\input.txt");\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Reader      inputStreamReader = new InputStreamReader(inputStream);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int data = inputStreamReader.read();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
while(data != -1)\{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    char theChar = (char) data;\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    data = inputStreamReader.read();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\}\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
inputStreamReader.close();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
example :\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
BufferedReader reader = new BufferedReader(isr)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
      String str;\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
      while ((str = reader.readLine()) != null) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
          System.out.println(str);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
      \}\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
FileReader\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
File Reader is subclass: to read file in character\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Reader reader = new FileReader("/path/to/file/thefile.txt");\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
char[] theChars = new char[128];\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int charsRead = reader.read(theChars, 0, theChars.length);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
while(charsRead != -1) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    System.out.println(new String(theChars, 0, charsRead));\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    charsRead = reader.read(theChars, 0, theChars.length);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\}\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
BufferReader\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Reader reader =\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    new BufferedReader(\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
        new FileReader("/path/to/file/thefile.txt"));\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int theCharNum = reader.read();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
while(theCharNum != -1) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    char theChar = (char) theCharNum;\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    System.out.print(theChar);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    theCharNum = reader.read();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\}\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
StringReader\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
The Java StringReader class enables you to turn an ordinary String into a Reader\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
JavaWriter:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A Writer is like an OutputStream except that it is character based rather than byte based.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
OutputStream:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
The Java OutputStreamWriter class, java.io.OutputStreamWriter, is intended to wrap an Java OutputStream\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
and thereby turning the byte based output stream into a character based Writer.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
OutputStream       outputStream       = new FileOutputStream("c:\\\\data\\\\output.txt");\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
outputStreamWriter.write("Hello World");\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
outputStreamWriter.close();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
FileWriter::\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
The Java FileWriter class, java.io.FileWriter, makes it possible to write characters to a file.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
In that respect the Java FileWriter works much like the FileOutputStream\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
except that a FileOutputStream is byte based, whereas a FileWriter is character based.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Overwriting vs. Appending the File\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
When you create a Java FileWriter you can decide if you want to overwrite any existing file with the same name,\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
or if you want to append to any existing file. You decide that by choosing what FileWriter constructor you use.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Writer fileWriter = new FileWriter("c:\\\\data\\\\output.txt", true);  //appends to file\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Writer fileWriter = new FileWriter("c:\\\\data\\\\output.txt", false); //overwrites file\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
BufferWriter:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
int bufferSize = 8 * 1024;\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
BufferedWriter bufferedWriter =\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
    new BufferedWriter(\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
        new FileWriter("c:\\\\data\\\\output-file.txt"),\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
            bufferSize);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Example:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
byte[] to String (text data)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
getByte (( example       byte[] bytes = str.getBytes(StandardCharsets.UTF_8); ))\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 String s = new String(bytes, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 Example 2:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 Convert byte[] to String (binary data)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 The below example converts an image phone.png into a byte[],\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 and uses the Java 8 Base64 class to convert the byte[] to a Base64 encoded String.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 Later, we convert the Base64 encoded string back to the original byte[]\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 and save it into another image named phone2.png.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
//read the file/ image in byte array\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
   byte[] bytes = Files.readAllBytes(path);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
   //convert the byte into bindary data with encder\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
               String s = Base64.getEncoder().encodeToString(bytes);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
               byte[] decode = Base64.getDecoder().decode(s);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                Files.write(Paths.get("/Users/mkyong/phone2.png"), decode);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls2\ilvl0
\f3\b \cf4 \kerning1\expnd0\expndtw0 		{\field{\*\fldinst{HYPERLINK "https://mkyong.com/java/how-do-convert-byte-array-to-string-in-java/"}}{\fldrslt \expnd0\expndtw0\kerning0
https://mkyong.com/java/how-do-convert-byte-array-to-string-in-java/}}
\f2\b0 \cf2 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0
\f3\b \cf4 \kerning1\expnd0\expndtw0 		{\field{\*\fldinst{HYPERLINK "https://mkyong.com/java/how-to-write-an-image-to-file-imageio/"}}{\fldrslt \expnd0\expndtw0\kerning0
https://mkyong.com/java/how-to-write-an-image-to-file-imageio/}}
\f2\b0 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
====================================================================================\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Files:\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
  List<String> list = Files.readAllLines(path, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
   Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 try (FileOutputStream fos = new FileOutputStream(file);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
       OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
       BufferedWriter writer = new BufferedWriter(osw)) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8)) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
 try (FileWriter fw = new FileWriter(new File(fileName), StandardCharsets.UTF_8);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
             BufferedWriter writer = new BufferedWriter(fw)) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
            for (String line : lines) \{\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                writer.append(line);\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
                writer.newLine();\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
            \}\cb1 \uc0\u8232 
\fs32 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls2\ilvl0
\f0\fs36 \cf2 \kerning1\expnd0\expndtw0 		\
		\
		Java 8 New Date And Time APIs\
		\
		java.time\
		  dates\
		   times\
		    Instants\
		   duration\
		 period\
		 time zones\
		 \
		\'97java.time.format\
		\'97java.time.temporal\
		\'97java.time.zone\
\pard\tx566\pardeftab720\sa80\partightenfactor0
\cf2 \
This is for user/humans\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls3\ilvl0\cf2 		LocalDate\
		LocalTime\
		LocalDateTime \
		\
		Instant is for machine normally\
		but all these apis has many static method to get temporal fields \
		\
		above all can be adjusted / manipulated on fixed & relative basis\
		TemporalAdjusters allow you to manipulate date in much more complex ways \
		Formater are there to format with defined formatter based on local & global ISO you can also create custom datetimeformater using builder provided by formatter class\
		there is timeZone as well which can be used to specify timezone relative specific region/location & as a fixed offset from UTC\
		All APis re thread safe\
		\expnd0\expndtw0\kerning0
\uc0\u8232 
\f2\fs32 \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa80\partightenfactor0
\ls3\ilvl0
\f4\fs36 \cf2 \kerning1\expnd0\expndtw0 		\
		Collectors API\
		\
		joining( char delimiter , prefix, suffix ) // multiple override \
		\
		.collect ( toList()\
		.collect(Collectors.toCollection(TreeSet::new)\
		\
		.collect(Collectors.joining(\'93, \'93);\
		\
		.collect(Collectors.summingint(Employe::getSalary);\
		\
		groupingBy(Employe:department)\
		groupingby(Employe::getDepartment, Collectors.summingInt(Employe::getSalary));\
		\
		//Partition students into passing and failing \
		Map<Boolean, List<Student> map = collect( partitioningBy(s-> s.getGrade > 2 ( predicate )) we can give collectors downstream as well to map data accordingly rather than taking whole object\
		\
		collect(partitioningBy(s-> predicate , mapping())\
		Map<Boolean , Map<>> map = collect(partioningBy(s-> predicate , groupingBy()\
		\
		\
		reduce ( identity , mapper , operator )\
		\
		mapper will be jus two modify the input if needed and then operator will be applied to all the input element passed .\
		\
		\
		\
		How to read a file in Java \
		\
		\
		List<String> lines = Files.readAllLines(Path.getpath(file path), encoding);\
		Stream<String> s = Files.lines(path, encoding)\
		\
		\
		Way1 :\
		\
		\
		File f = new File(\'93path\'94);\
		BufferReader br = new BufferReader ( new FileReader (file));\
		\
		str = br.readLine !=null && read all line 1 by 1\
		\
		way 2 : \
		FilReader fr = new FileReader(\'93path\'94);\
		\
		int i =fr.read != -1 \
		\
		sort (char) I;\
		\
		\
		way 3 :\
		File f ;\
		\
		Scanner s = new Scanner(file);\
		s.hasNextLines\
		\
		\
		way4 :\
		\
		List<String> s = Files,readAllLines(Paths.get(), StandardCharSets.UTF_8)\
		\
		\
		way5 :\
		\
		String data = new String(Files,readAllBytes(Paths.get(file path));\expnd0\expndtw0\kerning0
\uc0\u8232 
\f2\fs32 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\
\
\
\
\
}