Spring Interview Topics:


REST API vs MQ
Sync vs async
MQ when payload size is more
Rest when public api




How to inject prototype bean in singleton bean

By default, Spring beans are singletons. The problem arises when we try to wire beans of different scopes. For example, a prototype bean into a singleton. This is known as the scoped bean injection problem.
https://www.baeldung.com/spring-inject-prototype-bean-into-singleton


How to pass List to REST API endpoint
1) way pass via request param

@GetMapping
Public void testList(@RequestParam List<String> values)

Http:localhost:8080?values=first,second,third
Http:localhost:8080?values=first&values-second

2) way is via path param ( http path variable )
Http:localhost:8080/5,62,4

I wud like to use path variable since rest ideology is resource id is passed after resource name & http params ( request param ) is used for filtering


Important feature of spring is IOC container & interface bean factory & application context represent IOC container

Bean factory is root for accessing spring container

Types of application context
For different requirement

1) AnnotationConfigApplciationContext ( configure classes another with @Configuration @Component)
2)XMLWebApplicationContext  if we use xml based configuration in web application,
Xmlwebconfig.setConfigLocation(“/WEB/INF/spring.applicationContext.xml)

3)FileSystemXMLApplicationContext
When xml is located at some oath and not in class path

4) ClassPathXmlApplicationContext

How to exclude any configuration
@Autoconfiguration(exclude=“DataSourceConfiguration.class, MailSenderConfigurationsClass.class)



Application runner & Commandline Runner
When u want to run some code just after spring container is ready to server u can implement ApplicationRunner or Commandrunner & override unimplemented run() method

How to configure multiple data sources in spring/spring boot
So when we define data sources properties in application properties & DatasourceProperties class automatically auto wired the properties & data source initialisation & hiker setup done by default.

Now since we have 2 difference data bases we will create 2 Datasource properties & then we will create #configuration class where we will define 2 datasources bean one initiated with 1 datasource properties and another with another one..and either define different name or use qualifier to identify them & then initialise the jdbc tempelate bean one with each data source

2) if want to use these DS in repository then u need to create 2 config classes annote it with
@Configurations @EnableTxnMgmnt @EnableJpaRepsotiores( entityManagerRef =“” transactionManagerRef = “”)

CustomerConfig

Datasource initialisation with customerDBCOnfig
Create bean for EntityManagerFactory with this customer DS
Create transaction Manager bean with this entity manager factory

And when we invoke any method with repo we will define bean name with @Transaction annotation ( “” )


How Spring & hibernate Handle pagination

Jpa handle it via query , query.setFirstResult & query.maxResult()
Spring Data Jpa handle it via Pagaeble ( repo extends PagingAndSortingRepostory)
And we can pass custom pageable object in repo to fetch accordingly





Spring Controller & rest controller

@Controller is just a spring component & used in mvc application along with @RequestMapping annotation for request handling methods with @ResponseBody where rest controller its combo

So rest controller is same as controller if we use it with @ResponseBody but if not then flow will ve bit different..

1) Request -> request DispatcherServlter request  -> (request )handler Mapping( return Controller) -> (request )Controller (model & View ( response )) -> (view name )View Resolver (view) -> (view) Dispatcher servlet (model) -> (model) View (response ) -> response (DS) ( response to UI)

Where as in Rest controller response from controller will directly be sent o Dispatcher servlet & back to UI




Database pooling in spring boot application:
By default Apache Tomcat datasource pool is used for JDBC pools but if you want to use Hikari & then u can define it in pom & by default hiker will be picked u but if you are using spring 2+ then its by default pool. & u can customise the hiker property by defining it in application properties



What is restFul services:
Rest is specification & architecture style normally run over HTTP protocol ( but can run other protocols )

RestFul Api is interface that connect 2 computer system use to exchange data securely over internet.

API ( Application programming interface ) defines rule that you must follow to communicate to other software system.
Developers exposes  or create APIS so that other apps can communicate with their apps.

Resources: information that app provide to client
Eh : text, link , media


REST based API , it impose conditions & rule on how API should work . Its like a guideline work on URI ( uniform resource identifier ( called URL )
Principles of Rest:
Uniform Interface : formatted resources is called representation in REST.

Eg : Server can store data in text format but send in html format.

It indicate server will have standard format for data transfer.
UI impose 4 constraints:
1) Request should identify the resources
2) Client sue have enough info in resources implementation to modify or delete the resource if they want to.
3) Client sud receive the info about how to process the representation ( data ) further. This is done by meta data which we sent through http headers.
4) client sue receive information about all other resources they need to complete further task
( done via hyperlink href )

Rest based system are stateless & known about previous requests so can scale easily.

Cachebility : Rest based architecture services can support caching of some stale objects
Spring lifecycle in short

RestFul APIs require request to contain following main component:

1) URI since server identify resources by it. For rest services server performs resource identification via URL , it specifies path of resource.

2) Method ( GET/PUT/POST/PATCh/DELETE)



Spring bean life cycle:

Instantiation -> populate properties -> Aware Interface ( bean name & factory ) -> BeanPostProcess ( PreIntilisation/before ) -> InitlizingBean ( after property set ) -> custom-init -> @PreDestroy -> BeanPostProcessor ( postInit/After ) -> Bean will be ready to use

Destroy callbacks

Post destroy -> Disposablebean ( destroy ) -> custom destroy ->


Spring Transaction Abstraction is defined by Spring PlatformTransactionManager interface
—getTxn( TxnDefinition)
—commit
—rolback

TxnDefinition
—getPropogationBehavior
—getIsloationlevel
—getTimeout
—isReadOnly

Isolation
—default
—readuccommited
—readcommited
—repeatableRead
—serialzable

Propogation
—Mandatory ( if not then error )
—nested (
—never
Supports ( either case )
Not supported ( do not support current txn & execute non tonally )

—required_new
—required


Q1) Http put vs post request
When we do post method its not idempotent & create resource multiple times when invoked

Put operation is idempotent & multiple same calls won’t change the resource.



1) Difference Between bean & Component ?
Ans :
a)  bean is method level & Component is at class level.
b)@bean can create bean even if class is outside spring container ( library), classes which are library based & have no direct implementation in project. Bean require and sud be defined in @Confgiuration properties and so bean can’t be create using @compnent if class is outside

c) Bean also be used when we want some specific implementation based on some dynamic condition passed from arg. We cannot do same with component class eg: instantiation DataSource class dynamically  based on some input.

Sometimes automatic configuration is not an option. When? Let's imagine that you want to wire components from 3rd-party libraries (you don't have the source code so you can't annotate its classes with @Component), so automatic configuration is not possible.

The @Bean annotation returns an object that spring should register as bean in application context. The body of the method bears the logic responsible for creating the instance.

@Component Preferable for component scanning and automatic wiring.

============================================================================================

2) Dependency Injection &
Spring provide IOC using dependency injection through spring IOC container/ApplciationContext/beanFactory

Some ways for doing DI:@Autowired/@Inject/@Resource with @Qualifier

@Autowired and @Inject

1.Match by Type -> bean with same Data type of the variable should be available in spring container

2.Restricts by Qualifier -> If bean of variable’s data type not found or many implementation of the type available then it looks for any qualifier defined and if defined it uses Qualifier and wont go for 3rd option

3.Matches by Name –> searches the bean in the spring whose id should be same as variable name defined while autowiring.

@Resource

1.Match by Name -> first it searches for the bean in spring whose id should be same as variable name declared.

2.Match by Type -> bean with same Data type of the variable should be available in spring container

3.Restricts by Qualifier(ignores if 1st attempt said above by name matches)

http://javainsimpleway.com/autowired-resource-and-inject-2/?msclkid=8c0166b9ac4911ec8b0df8aff8529829

============================================================================================

Q3 ) what are scopes in Spring ??
Ans)

Scope	Description
Singleton	 It scopes a single bean definition into a single object instance per Spring IoC Container. It is the default scope type.
Prototype	 It scopes a single bean definition into any number of object instances (required amount).
Request	Itscopes a single bean definition to the lifecycle of a single HTTP request. It is used only with the web-aware applications.
Session	Itscopes a single bean definition to the lifecycle of an HTTP session. It is used only with the web-aware applications.
global session	Itscopes a single bean definition to the lifecycle of a global HTTP session. It is used only with the web-aware applications.
https://www.journaldev.com/21206/spring-postconstruct-predestroy

So it’s clear that spring container is initializing the bean on every request, calling its @PostConstruct method and then handing it over to the client. Spring is not managing the bean after that and in this case, the client has to perform all the resource cleanup by directly calling the PreDestroy method. ( wont work in prototype )


============================================================================================



Q4) Spring LifeCycle( Instiantiation , aware interface postProcessBefore initilisation , callbacks , after properties set , @Post-contruct, custom init method )

https://dzone.com/articles/spring-bean-lifecycle

https://howtodoinjava.com/spring-core/spring-bean-life-cycle/?msclkid=61727483ac4b11ecb42df8854d3620fa

No practically I don't think there is any difference but there are priorities in the way they work. @PostConstruct, init-method are BeanPostProcessors.

@PostConstruct is a JSR-250 annotation while init-method is Spring's way of having an initializing method.
If you have a @PostConstruct method, this will be called first before the initializing methods are called.
If your bean implements InitializingBean and overrides afterPropertiesSet , first @PostConstruct is called, then the afterPropertiesSet and then init-method.

===============================================================================================


Q5) Spring Modules:

===============================================================================================
The Core container from Spring consists of four modules: SpEL Core(DI & IOC), Beans, context

Description for these elements are as follows:
The SpEL module provides a powerful expression language for manipulating objects during execution.
Context is built on the basis of Beans and Core and allows you to access any object that is defined in the settings. The key element of the Context module is the ApplicationContext interface.
The Core module provides key parts of the framework including IoC and DI properties.
The Bean module is responsible for creating and managing Spring Beans – is application context structure unit.
===============================================================================================


Q6 ) how to create your own actuator endpoint

@Endpoint(id="myendpoint")
@Component
public class MyCustomEndpoints {

	@ReadOperation
	@Bean
	public String hi() {
		return "Hi from custom endpoint";
	}
}
management.endpoints.web.exposure.include=health,info,beans,env,myendpoint

============================================================================================


Q7 ) Spring Boot handling external properties \ properties resource & configurations ( @Confgiurtionproperties & PropertyResource )

https://springframework.guru/reading-external-configuration-properties-in-spring/
https://mkyong.com/spring-boot/spring-boot-configurationproperties-example/
https://reflectoring.io/spring-boot-configuration-properties/

PropertySources
JVM SystemProeprties/ operating System Properties come arguments application.properties. application.yml

============================================================================================

Q8 ) Error handling in Spring & ( @Controller advice , @ Exception controller , @Response status on exception class , ResponseEntityException )

https://mkyong.com/spring-boot/spring-rest-error-handling-example/
https://mkyong.com/spring-boot/spring-rest-validation-example/

============================================================================================


Q9 ) Spring Dispatcher Servlet. & HTTP Request & Response

Spring Boot provides the spring-boot-starter-web library for developing web applications using Spring MVC. One of the main features of Spring Boot is autoconfiguration. The Spring Boot autoconfiguration registers and configures the DispatcherServlet automatically. Therefore, we don’t need to register the DispatcherServlet manually.

WebAppInitializer interface
AbstractDispatcherServletInitializer abstract class
AbstractAnnotationConfigDispatcherServletInitializer abstract class


https://dzone.com/articles/lifecycle-of-a-request-response-process-for-a-spri
https://howtodoinjava.com/spring5/webmvc/spring-dispatcherservlet-tutorial/
https://www.oreilly.com/content/how-a-restful-api-server-reacts-to-requests/



============================================================================================


Q10 ) Validation in Spring boot & @Validation , @valid , @Param validtion
https://reflectoring.io/bean-validation-with-spring-boot/

============================================================================================

Q11) Spring Container Events / Event handeling in Application context

Application content & listners & events
3.8.3. Events
Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface. If a bean which implements the ApplicationListener interface is deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext, that bean will be notified. Essentially, this is the standard Observer design pattern. Spring provides the following standard events:
https://docs.spring.io/spring-framework/docs/2.5.x/reference/beans.html#context-introduction-ctx-vs-beanfactory

Built-in Events
https://docs.spring.io/spring-framework/docs/2.5.x/reference/beans.html#context-introduction-ctx-vs-beanfactory

============================================================================================

Q12 ) Spring Custom Annotation & How to create custom annotation
https://fullstackdeveloper.guru/2021/06/15/how-to-create-a-custom-annotation-in-spring-boot/



============================================================================================

Q13 ) servlet filter/web filter do filter method ) in spring & boot

Servlet chaining



============================================================================================

Q14 ) @Bean & @Componenet & @service @Controller @Repository

============================================================================================

Q15 ) GlobalFilter & webHTTpRequestInterceptior

============================================================================================

Q16) spring security & authenticator & security filter


Q16 a) What is the difference between @PreAuthorize, @Secured and @RolesAllowed?
Secured & roles allowed are same ( one 1 spring other is java ) annotation takes in ( role/ authority) as value
@PreAuthorize/@PostAuthorize are also (newer) Spring specific annotations and more powerful than the above annotations, as they can contain not only authorities/roles, but also any valid SpEL expression.
@PreAuthorize takes in authorities, but also any valid SpEL expression.

Q16 b) csrf
https://www.youtube.com/watch?v=vRBihr41JTo


============================================================================================

Q17) Spring Injection type (via name, type qualifier)







https://www.javainuse.com/webseries/spring-security-jwt/chap3



============================================================================================

Q18 ) 17) difference in beanAware factory & application context

https://dzone.com/articles/difference-between-beanfactory-and-applicationcont

these two interfaces supply the way to reach Spring beans from the container, but there are some significant differences.
Spring beans are Java objects that are managed by the Spring container.
The Spring container is responsible for instantiating, configuring, and assembling the Spring beans.
The BeanFactory Interface
This is the root interface for accessing the Spring container. To access the Spring container, we will be using Spring's dependency injection functionality using this BeanFactory interface and its sub-interfaces.
Features:
	•	Bean instantiation/wiring
Usually, the implementations use lazy loading, which means that beans are only instantiating when we directly calling them through the getBean() method.
The most used API that implements the BeanFactory is the XmlBeanFactory.

The ApplicationContext Interface
The ApplicationContext is the central interface within a Spring application that is used for providing configuration information to the application.
It implements the BeanFactory interface. Hence, the ApplicationContext includes all functionality of the BeanFactory and much more! Its main function is to support the creation of big business applications.
Features:
	•	Bean instantiation/wiring
	•	Automatic BeanPostProcessor registration
	•	Automatic BeanFactoryPostProcessor registration
	•	Convenient MessageSource access (for i18n)
	•	ApplicationEvent publication


============================================================================================


Q19 ) register programatically classes in spring container

1 way to do it via extending beandefintionPostProcessor
Or via ApplicationContextInitializer
U can call registerBean on applciationcontext ( appCo.registerbean(CustomBean.class,”desciption”)

& if in spring boot application
SpringApplicationBuilder(BeanFactoryApplication.class).inilitlizer(CustomBean.class).run());



Can be done by using bean factory to register it

============================================================================================


Q20 ) testing with spring

============================================================================================

Q20) Spring AOP ( advice, Joint point , point cut , weaving )

============================================================================================

Q21) how headers are injected into spring ( concept of interceptor )

============================================================================================

Q22) Distributed tracing

============================================================================================

Q23 ) spring & spring cloud with JMS & AMQP & KAFKA

============================================================================================

Q24 ) what are Spring/spring boot annotations
Ans )
@RequestBody @ResonseBody @Pathvariable @Getmapping @Resourse @Autowired @Inject @Qualifier @Repository @Service @Entity @Valid @MIn/Max/nonnull

============================================================================================

Q25) Spring transaction request propagation & isolation & ow to enable it

Propogation:
Required
requrired_new
Support
NotSupport
Never
Mandatory
Nested

Isolation
ReadUncomiited
ReadCommited
Repetable reads
Serialzable

To solve below issues

Dirty Read
NonRepetable reads
Phantom Read

============================================================================================

Q26) Internationalisation in spring ( through message source interface) automatic detect resources in class-path

============================================================================================

Q27 ) How REstTemplate connect to custom URLS
Ans ) restTemplate is also a high-level API, which in turn is based on an HTTP client,
But Spring framework is just not bind to rest template you can use any other http Clint Api if you want….
resttemplate.exchange( url , TYPE, entity params
public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException {

To easily manipulate URLs / path / params / etc., you can use Spring's UriComponentsBuilder class to create a URL template with placehoders for the parameters, then provide the value for those parameters in the RestOperations.exchange(...) call. It's cleaner than manually concatenating strings and it takes care of the URL encoding for you:

Appraoch 1:
-----------------------------------------------------------------------------------------------------
HttpHeaders headers = new HttpHeaders();
headers.set(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);
HttpEntity<?> entity = new HttpEntity<>(headers);

String urlTemplate = UriComponentsBuilder.fromHttpUrl(url)
        .queryParam("msisdn", "{msisdn}")
        .queryParam("email", "{email}")
        .queryParam("clientVersion", "{clientVersion}")
        .queryParam("clientType", "{clientType}")
        .queryParam("issuerName", "{issuerName}")
        .queryParam("applicationName", "{applicationName}")
        .encode()
        .toUriString();

Map<String, ?> params = new HashMap<>();
params.put("msisdn", msisdn);
params.put("email", email);
params.put("clientVersion", clientVersion);
params.put("clientType", clientType);
params.put("issuerName", issuerName);
params.put("applicationName", applicationName);

HttpEntity<String> response = restOperations.exchange(
        urlTemplate,
        HttpMethod.GET,
        entity,
        String.class,
        params
);

-----------------------------------------------
approach 2
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(new DefaultUriBuilderFactory("http://localhost:8080"));
restTemplate.getForObject("/myservice", String.class);

Custom HTTP Header with the HttpClient

//commmon
HttpClient client = HttpClients.custom().build();
HttpClient client = HttpClients.custom().setDefaultHeaders(headers).build();
HttpClient client = new DefaultHttpClient();


way 1:
HttpUriRequest request = RequestBuilder.get()
  .setUri(SAMPLE_URL)
  .setHeader(HttpHeaders.CONTENT_TYPE, "application/json")
  .build();

way 2:
  HttpGet request = new HttpGet(SAMPLE_URL);
request.setHeader(HttpHeaders.CONTENT_TYPE, "application/json");

Header header = new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json");
List<Header> headers = Lists.newArrayList(header);
HttpClient client = HttpClients.custom().setDefaultHeaders(headers).build();


client.execute(request);


way of performing HTTP requests in Java

The HttpUrlConnection class allows us to perform basic HTTP requests without the use of any additional libraries. All the classes that we need are part of the java.net package.

Creating a Request
We can create an HttpUrlConnection instance using the openConnection() method of the URL class. Note that this method only creates a connection object but doesn't establish the connection yet.

The HttpUrlConnection class is used for all types of requests by setting the requestMethod attribute to one of the values: GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE.

Let's create a connection to a given URL using GET method:

//syncronous connection
URL url = new URL("http://example.com");
HttpURLConnection con = (HttpURLConnection) url.openConnection();
con.setRequestMethod("GET");


con.setRequestProperty("Content-Type", "application/json");

Connection timeout
con.setConnectTimeout(5000);
con.setReadTimeout(5000);


Q40) Spring annotation:

Rest EndPoint”
@SpringBootApplciation,@RestController,@Requestmapping,pathvariable,@RequestBody

PeriodicTasks
@Scheduled,@EnableScheduling,@Configuration,@Bean

SpringManagedComponent
@Confgiuration,@Valdiation,@Service, @Repository

Persistence
@Entity,@Id,@genratevalue,@EnableJpaRespositiores,@EnableTransactionmanagement

Micelinous:
@Autowired,@Inject,@Qualifier,@Resource,@ConfigurationProeprties

Testing @SpringBootTest @AutoConfigureMockMvc


Q41) Difference between @Controller &RestController

Q42) Difference between @Resource & Configuration properties
@ConfigurationProperties is used to map properties with POJO beans. Then you could use bean to access the properties values in your application.
@PropertySource is to reference a properties file and load it.
@Value is to inject a particular property value by it's key.

@Value("${spring.application.name}") @Value will throw exception if there no matching key in application.properties/yml file. It strictly injects property value.

@ConfigurationProperties(prefix = "myserver.allvalues") injects POJO properties, it's not strict, it ignores the property if there is no key in properties file.




Q43 ) what is difference between yml & app.propeties

Its usage is quite prevalent in many languages like Python, Ruby, and Java
It is primarily used in java
Hierarchical Structure
Non-Hierarchical Structure
Spring Framework doesn’t support @PropertySources with .yml files
supports @PropertySources with .properties file
If you are using spring profiles, you can have multiple profiles in one single .yml file
Each profile need one separate .properties file
While retrieving the values from .yml file we get the value as whatever the respective type (int, string etc.) is in the configuration
While in case of the .properties files we get strings regardless of what the actual value type is in the configuration




OAuth & OpenId connect

https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a


Open Authorisation is standard protocol for delagating authorisation.
It allows apps to access user data without user name password

OAuth 2.0
4 important c/p
1)Resource Owner ( user who owns the data that client want to access )
 /Client /
 Authorisation server ( authorisation server authorises the client to access a user’s data by granting permissions from user )
/Resource server  ( system that holds the user data )
/Access tokens token used for grant permission

User opens apps & apps want to access user profile/contact & then client request ask for authorisation grants & then server will ask user to provide grants ( allow or deny ) & when client do login & consent autgizationCode will be shared with the client & now client will use the auth code to connect to resource server to get the resource ( well resource server will al validate token with auth server to double check the client & code )

When client send auth request to auth server
Request will have
Response type
Scope ( what client want to access )
cleant_id ( setup at auth service to identify client )
Redirectui / callbackuri ( where to go once auth flow is complete )
client_secret

If browser based client is there then client server take the auth code and again query with auth server to get token

Oauth2.0 autharizes & delegate the auth but it did not identify/valdiated the user

And for that OpenID connect is used
Its an identity layer top of Auth 2.0 protocol

OpenIDConnect enables the client to identify the user based on auth performed by auth server
This is achieved by scope called open_id

open_id is mandatory scope to tell auth server that openID connect is required
Eg: url / response_type=code&client_id=ypur+client&scope=opeid%contacts&redirecturi-

The result of the request is application code that the client can exchange for access token & id token if auth flow is implicit then auth server reponds with accesstoekn & id token rightway

The id token is JWT or JSON web token. A JWT is encoded token that consists of 3 parts header payload & signature
And the user can decode id token to get user Info




Hibernate disadvantage
Might be bit slower than jdbc


Hibernate persist & save method
Difference depend upon the id generator class we are using
If generator class is assigned then there is no difference since we will give the primary id

If its Increment then hibernate assign the primary key id into db right & so save will give the primary key & press won’t give you the primary key

Hibernate different state of entity



Hibernate difference between update & merge

Both are used to convert object which is in detacehed state into pursuance state




Hibernate life cycle

In Hibernate , either we create an object of an entity & save it into db or we fetch data from an entity from db . So each entity object pass through a life cycle

1) Transient
2) Persistent
3) Detached

If we call get()/load() we will directly get persistent entity attached with session

If we create a new entity then it will be in transient state & when we call save/persist/saveOrUpdate()/update() transient state will convert to Persistent state

And when we call detach/close/clear/evict on Persistent it make it to Detached state

And when we call delete on persistent entity it will make it to transient


Detached to Persistence can be done by save/saveOrUpdate/metge/lock




