Spring Interview Topics:
Sprig questions : https://www.javapedia.net/Spring-Boot/3088ring
https://www.baeldung.com/jpa-hibernate-batch-insert-update

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
After removing the tomcat dependency, the next step is to specify the dependency for jetty.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>


Can we have multiple context in single spring jvm
bydefault single context is preffered so better autowiring is possible sinle spring need to look into single context to bind the bean //

but yes we can define the multiple context via new key keyword like new ClassPathXMLApplication context & give name to context
and while taking out bean we specifically need to get bean fromr respective context





http headers https://www.geeksforgeeks.org/http-headers/
General Header: This type of headers applied on Request and Response headers both but with out affecting the database body.
Request Header: This type of headers contains information about the fetched request by the client.
Response Header: This type of headers contains the location of the source that has been requested by the client.
Entity Header: This type of headers contains the information about the body of the resources like MIME type, Content-length.



MIME type Multi-purpose Internet Mail Extensions.
A MIME type is a label used to identify a type of data

This is text/html" the client can go "Ah, this is an HTML document, I can render that internally",
 "This is application/pdf" the client can go "Ah, I need to launch the
  FoxIt PDF Reader plugin that the user has installed and that has registered itself as the application/pdf handler."

bydefault sring boot application produces json but if you want to change default to xml then
if jackson_XMl is in classpath jsut add produces annotation either at class level or at method
produces = {MediaType.Application_XML_VALUE} & if you want to give multiple option u can give in produces tag via ,

same way we can have consumes & these tags also restrict the ouput & inout given to your spring boot app.




MDC context

ThreadLocal


stereotype annotations in spring are @Component, @Service, @Repository, and @Controller.
 @Component is a class-level annotation. It is used to denote a class as a Component.

n spring autowiring, @Autowired annotation handles only wiring part.
 We still have to define the beans so the container is aware of them and can inject them for us.

With @Component, @Repository, @Service and @Controller annotations in place and automatic component scanning enabled,
Spring will automatically import the beans into the container and inject to dependencies. These annotations are called Stereotype annotations as well.

Enable component scanning
applicationContext.xml
<context:component-scan base-package="com.howtodoinjava.demo.service" />

REST API vs MQ
Sync vs async
MQ when payload size is more
Rest when public api




How to inject prototype bean in singleton bean

By default, Spring beans are singletons. The problem arises when we try to wire beans of different scopes. For example, a prototype bean into a singleton. This is known as the scoped bean injection problem.
https://www.baeldung.com/spring-inject-prototype-bean-into-singleton


How to pass List<Integer> to REST API endpoint
1) way pass via request param

@GetMapping
Public void testList(@RequestParam List<String> values)

Http:localhost:8080?values=first,second,third
Http:localhost:8080?values=first&values-second

2) way is via path param ( http path variable )
Http:localhost:8080/5,62,4

I wud like to use path variable since rest ideology is resource id is passed after resource name & http params ( request param ) is used for filtering


Important feature of spring is IOC container & interface bean factory & application context represent IOC container

Bean factory is root for accessing spring container

Types of application context
For different requirement

1) AnnotationConfigApplciationContext ( configure classes another with @Configuration @Component)
2)XMLWebApplicationContext  if we use xml based configuration in web application,
Xmlwebconfig.setConfigLocation(“/WEB/INF/spring.applicationContext.xml)

3)FileSystemXMLApplicationContext
When xml is located at some oath and not in class path

4) ClassPathXmlApplicationContext

How to exclude any configuration
@Autoconfiguration(exclude=“DataSourceConfiguration.class, MailSenderConfigurationsClass.class)



Application runner & Commandline Runner
When u want to run some code just after spring container is ready to server u can implement ApplicationRunner or Commandrunner & override unimplemented run() method

How to configure multiple data sources in spring/spring boot
So when we define data sources properties in application properties & DatasourceProperties class automatically auto wired the properties & data source initialisation & hiker setup done by default.

Now since we have 2 difference data bases we will create 2 Datasource properties & then we will create #configuration class where we will define 2 datasources bean one initiated with 1 datasource properties and another with another one..and either define different name or use qualifier to identify them & then initialise the jdbc tempelate bean one with each data source

2) if want to use these DS in repository then u need to create 2 config classes annote it with
@Configurations @EnableTxnMgmnt @EnableJpaRepsotiores( entityManagerRef =“” transactionManagerRef = “”)

CustomerConfig

Datasource initialisation with customerDBCOnfig
Create bean for EntityManagerFactory with this customer DS
Create transaction Manager bean with this entity manager factory

And when we invoke any method with repo we will define bean name with @Transaction annotation ( “” )


How Spring & hibernate Handle pagination

Jpa handle it via query , query.setFirstResult & query.maxResult()
Spring Data Jpa handle it via Pagaeble ( repo extends PagingAndSortingRepostory)
And we can pass custom pageable object in repo to fetch accordingly





Spring Controller & rest controller

@Controller is just a spring component & used in mvc application along with @RequestMapping annotation for request handling methods with @ResponseBody where rest controller its combo

So rest controller is same as controller if we use it with @ResponseBody but if not then flow will ve bit different..

1) Request -> request DispatcherServlter request  -> (request )handler Mapping( return Controller) -> (request )Controller (model & View ( response )) -> (view name )View Resolver (view) -> (view) Dispatcher servlet (model) -> (model) View (response ) -> response (DS) ( response to UI)

Where as in Rest controller response from controller will directly be sent o Dispatcher servlet & back to UI




Database pooling in spring boot application:
By default Apache Tomcat datasource pool is used for JDBC pools but if you want to use Hikari & then u can define it in pom & by default hiker will be picked u but if you are using spring 2+ then its by default pool. & u can customise the hiker property by defining it in application properties



What is restFul services:
Rest is specification & architecture style normally run over HTTP protocol ( but can run other protocols )

RestFul Api is interface that connect 2 computer system use to exchange data securely over internet.

API ( Application programming interface ) defines rule that you must follow to communicate to other software system.
Developers exposes  or create APIS so that other apps can communicate with their apps.

Resources: information that app provide to client
Eh : text, link , media


REST based API , it impose conditions & rule on how API should work . Its like a guideline work on URI ( uniform resource identifier ( called URL )
Principles of Rest:
Uniform Interface : formatted resources is called representation in REST.

Eg : Server can store data in text format but send in html format.

It indicate server will have standard format for data transfer.
UI impose 4 constraints:
1) Request should identify the resources
2) Client sue have enough info in resources implementation to modify or delete the resource if they want to.
3) Client sud receive the info about how to process the representation ( data ) further. This is done by meta data which we sent through http headers.
4) client sue receive information about all other resources they need to complete further task
( done via hyperlink href )

Rest based system are stateless & known about previous requests so can scale easily.

Cachebility : Rest based architecture services can support caching of some stale objects
Spring lifecycle in short

RestFul APIs require request to contain following main component:

1) URI since server identify resources by it. For rest services server performs resource identification via URL , it specifies path of resource.

2) Method ( GET/PUT/POST/PATCh/DELETE)



Spring bean life cycle:

Instantiation -> populate properties -> Aware Interface ( bean name & factory ) -> BeanPostProcess ( PreIntilisation/before ) -> InitlizingBean ( after property set ) -> custom-init -> @PreDestroy -> BeanPostProcessor ( postInit/After ) -> Bean will be ready to use

Destroy callbacks

Post destroy -> Disposablebean ( destroy ) -> custom destroy ->


Spring Transaction Abstraction is defined by Spring PlatformTransactionManager interface
—getTxn( TxnDefinition)
—commit
—rolback

TxnDefinition
—getPropogationBehavior
—getIsloationlevel
—getTimeout
—isReadOnly

Isolation
—default
—readuccommited
—readcommited
—repeatableRead
—serialzable

Propogation
—Mandatory ( if not then error )
—nested (
—never
Supports ( either case )
Not supported ( do not support current txn & execute non tonally )

—required_new
—required


Q1) Http put vs post request
When we do post method its not idempotent & create resource multiple times when invoked

Put operation is idempotent & multiple same calls won’t change the resource.



1) Difference Between bean & Component ?
Ans :
a)  bean is method level & Component is at class level.
b)@bean can create bean even if class is outside spring container ( library), classes which are library based & have no direct implementation in project. Bean require and sud be defined in @Confgiuration properties and so bean can’t be create using @compnent if class is outside

c) Bean also be used when we want some specific implementation based on some dynamic condition passed from arg. We cannot do same with component class eg: instantiation DataSource class dynamically  based on some input.

Sometimes automatic configuration is not an option. When? Let's imagine that you want to wire components from 3rd-party libraries (you don't have the source code so you can't annotate its classes with @Component), so automatic configuration is not possible.

The @Bean annotation returns an object that spring should register as bean in application context. The body of the method bears the logic responsible for creating the instance.

@Component Preferable for component scanning and automatic wiring.

============================================================================================

2) Dependency Injection &
Spring provide IOC using dependency injection through spring IOC container/ApplciationContext/beanFactory

Some ways for doing DI:@Autowired/@Inject/@Resource with @Qualifier

@Autowired and @Inject

1.Match by Type -> bean with same Data type of the variable should be available in spring container

2.Restricts by Qualifier -> If bean of variable’s data type not found or many implementation of the type available then it looks for any qualifier defined and if defined it uses Qualifier and wont go for 3rd option

3.Matches by Name –> searches the bean in the spring whose id should be same as variable name defined while autowiring.

@Resource

1.Match by Name -> first it searches for the bean in spring whose id should be same as variable name declared.

2.Match by Type -> bean with same Data type of the variable should be available in spring container

3.Restricts by Qualifier(ignores if 1st attempt said above by name matches)

http://javainsimpleway.com/autowired-resource-and-inject-2/?msclkid=8c0166b9ac4911ec8b0df8aff8529829

============================================================================================

Q3 ) what are scopes in Spring ??
Ans)

Scope	Description
Singleton	 It scopes a single bean definition into a single object instance per Spring IoC Container. It is the default scope type.
Prototype	 It scopes a single bean definition into any number of object instances (required amount).
Request	Itscopes a single bean definition to the lifecycle of a single HTTP request. It is used only with the web-aware applications.
Session	Itscopes a single bean definition to the lifecycle of an HTTP session. It is used only with the web-aware applications.
global session	Itscopes a single bean definition to the lifecycle of a global HTTP session. It is used only with the web-aware applications.
https://www.journaldev.com/21206/spring-postconstruct-predestroy

So it’s clear that spring container is initializing the bean on every request, calling its @PostConstruct method and then handing it over to the client. Spring is not managing the bean after that and in this case, the client has to perform all the resource cleanup by directly calling the PreDestroy method. ( wont work in prototype )


============================================================================================



Q4) Spring LifeCycle( Instiantiation , aware interface postProcessBefore initilisation , callbacks , after properties set , @Post-contruct, custom init method )

https://dzone.com/articles/spring-bean-lifecycle

https://howtodoinjava.com/spring-core/spring-bean-life-cycle/?msclkid=61727483ac4b11ecb42df8854d3620fa

No practically I don't think there is any difference but there are priorities in the way they work. @PostConstruct, init-method are BeanPostProcessors.

@PostConstruct is a JSR-250 annotation while init-method is Spring's way of having an initializing method.
If you have a @PostConstruct method, this will be called first before the initializing methods are called.
If your bean implements InitializingBean and overrides afterPropertiesSet , first @PostConstruct is called, then the afterPropertiesSet and then init-method.

===============================================================================================


Q5) Spring Modules:

===============================================================================================
The Core container from Spring consists of four modules: SpEL Core(DI & IOC), Beans, context

Description for these elements are as follows:
The SpEL module provides a powerful expression language for manipulating objects during execution.
Context is built on the basis of Beans and Core and allows you to access any object that is defined in the settings. The key element of the Context module is the ApplicationContext interface.
The Core module provides key parts of the framework including IoC and DI properties.
The Bean module is responsible for creating and managing Spring Beans – is application context structure unit.
===============================================================================================


Q6 ) how to create your own actuator endpoint

@Endpoint(id="myendpoint")
@Component
public class MyCustomEndpoints {

	@ReadOperation
	@Bean
	public String hi() {
		return "Hi from custom endpoint";
	}
}
management.endpoints.web.exposure.include=health,info,beans,env,myendpoint

============================================================================================


Q7 ) Spring Boot handling external properties \ properties resource & configurations ( @Confgiurtionproperties & PropertyResource )

https://springframework.guru/reading-external-configuration-properties-in-spring/
https://mkyong.com/spring-boot/spring-boot-configurationproperties-example/
https://reflectoring.io/spring-boot-configuration-properties/

PropertySources
JVM SystemProeprties/ operating System Properties come arguments application.properties. application.yml

============================================================================================

Q8 ) Error handling in Spring & ( @Controller advice , @ Exception controller , @Response status on exception class , ResponseEntityException )

https://mkyong.com/spring-boot/spring-rest-error-handling-example/
https://mkyong.com/spring-boot/spring-rest-validation-example/

============================================================================================


Q9 ) Spring Dispatcher Servlet. & HTTP Request & Response

Spring Boot provides the spring-boot-starter-web library for developing web applications using Spring MVC. One of the main features of Spring Boot is autoconfiguration. The Spring Boot autoconfiguration registers and configures the DispatcherServlet automatically. Therefore, we don’t need to register the DispatcherServlet manually.

WebAppInitializer interface
AbstractDispatcherServletInitializer abstract class
AbstractAnnotationConfigDispatcherServletInitializer abstract class


https://dzone.com/articles/lifecycle-of-a-request-response-process-for-a-spri
https://howtodoinjava.com/spring5/webmvc/spring-dispatcherservlet-tutorial/
https://www.oreilly.com/content/how-a-restful-api-server-reacts-to-requests/



============================================================================================


Q10 ) Validation in Spring boot & @Validation , @valid , @Param validtion
https://reflectoring.io/bean-validation-with-spring-boot/

============================================================================================

Q11) Spring Container Events / Event handeling in Application context

Application content & listners & events
3.8.3. Events
Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface. If a bean which implements the ApplicationListener interface is deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext, that bean will be notified. Essentially, this is the standard Observer design pattern. Spring provides the following standard events:
https://docs.spring.io/spring-framework/docs/2.5.x/reference/beans.html#context-introduction-ctx-vs-beanfactory

Built-in Events
https://docs.spring.io/spring-framework/docs/2.5.x/reference/beans.html#context-introduction-ctx-vs-beanfactory

============================================================================================

Q12 ) Spring Custom Annotation & How to create custom annotation
https://fullstackdeveloper.guru/2021/06/15/how-to-create-a-custom-annotation-in-spring-boot/



============================================================================================

Q13 ) servlet filter/web filter do filter method ) in spring & boot

Servlet chaining



============================================================================================

Q14 ) @Bean & @Componenet & @service @Controller @Repository

============================================================================================

Q15 ) GlobalFilter & webHTTpRequestInterceptior

============================================================================================

Q16) spring security & authenticator & security filter


Q16 a) What is the difference between @PreAuthorize, @Secured and @RolesAllowed?
Secured & roles allowed are same ( one 1 spring other is java ) annotation takes in ( role/ authority) as value
@PreAuthorize/@PostAuthorize are also (newer) Spring specific annotations and more powerful than the above annotations, as they can contain not only authorities/roles, but also any valid SpEL expression.
@PreAuthorize takes in authorities, but also any valid SpEL expression.

Q16 b) csrf
https://www.youtube.com/watch?v=vRBihr41JTo


============================================================================================

Q17) Spring Injection type (via name, type qualifier)







https://www.javainuse.com/webseries/spring-security-jwt/chap3



============================================================================================

Q18 ) 17) difference in beanAware factory & application context

https://dzone.com/articles/difference-between-beanfactory-and-applicationcont

these two interfaces supply the way to reach Spring beans from the container, but there are some significant differences.
Spring beans are Java objects that are managed by the Spring container.
The Spring container is responsible for instantiating, configuring, and assembling the Spring beans.
The BeanFactory Interface
This is the root interface for accessing the Spring container. To access the Spring container, we will be using Spring's dependency injection functionality using this BeanFactory interface and its sub-interfaces.
Features:
	•	Bean instantiation/wiring
Usually, the implementations use lazy loading, which means that beans are only instantiating when we directly calling them through the getBean() method.
The most used API that implements the BeanFactory is the XmlBeanFactory.

The ApplicationContext Interface
The ApplicationContext is the central interface within a Spring application that is used for providing configuration information to the application.
It implements the BeanFactory interface. Hence, the ApplicationContext includes all functionality of the BeanFactory and much more! Its main function is to support the creation of big business applications.
Features:
	•	Bean instantiation/wiring
	•	Automatic BeanPostProcessor registration
	•	Automatic BeanFactoryPostProcessor registration
	•	Convenient MessageSource access (for i18n)
	•	ApplicationEvent publication


============================================================================================


Q19 ) register programatically classes in spring container

1 way to do it via extending beandefintionPostProcessor
Or via ApplicationContextInitializer
U can call registerBean on applciationcontext ( appCo.registerbean(CustomBean.class,”desciption”)

& if in spring boot application
SpringApplicationBuilder(BeanFactoryApplication.class).inilitlizer(CustomBean.class).run());



Can be done by using bean factory to register it

============================================================================================


Q20 ) testing with spring

============================================================================================

Q20) Spring AOP ( advice, Joint point , point cut , weaving )

============================================================================================

Q21) how headers are injected into spring ( concept of interceptor )

============================================================================================

Q22) Distributed tracing

============================================================================================

Q23 ) spring & spring cloud with JMS & AMQP & KAFKA

============================================================================================

Q24 ) what are Spring/spring boot annotations
Ans )
@RequestBody @ResonseBody @Pathvariable @Getmapping @Resourse @Autowired @Inject @Qualifier @Repository @Service @Entity @Valid @MIn/Max/nonnull

============================================================================================

Q25) Spring transaction request propagation & isolation & ow to enable it

Propogation:
Required
requrired_new
Support
NotSupport
Never
Mandatory
Nested

Isolation
ReadUncomiited
ReadCommited
Repetable reads
Serialzable

To solve below issues

Dirty Read
NonRepetable reads
Phantom Read

============================================================================================

Q26) Internationalisation in spring ( through message source interface) automatic detect resources in class-path

============================================================================================

Q27 ) How REstTemplate connect to custom URLS
Ans ) restTemplate is also a high-level API, which in turn is based on an HTTP client,
But Spring framework is just not bind to rest template you can use any other http Clint Api if you want….
resttemplate.exchange( url , TYPE, entity params
public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException {

To easily manipulate URLs / path / params / etc., you can use Spring's UriComponentsBuilder class to create a URL template with placehoders for the parameters, then provide the value for those parameters in the RestOperations.exchange(...) call. It's cleaner than manually concatenating strings and it takes care of the URL encoding for you:

Appraoch 1:
-----------------------------------------------------------------------------------------------------
HttpHeaders headers = new HttpHeaders();
headers.set(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);
HttpEntity<?> entity = new HttpEntity<>(headers);

String urlTemplate = UriComponentsBuilder.fromHttpUrl(url)
        .queryParam("msisdn", "{msisdn}")
        .queryParam("email", "{email}")
        .queryParam("clientVersion", "{clientVersion}")
        .queryParam("clientType", "{clientType}")
        .queryParam("issuerName", "{issuerName}")
        .queryParam("applicationName", "{applicationName}")
        .encode()
        .toUriString();

Map<String, ?> params = new HashMap<>();
params.put("msisdn", msisdn);
params.put("email", email);
params.put("clientVersion", clientVersion);
params.put("clientType", clientType);
params.put("issuerName", issuerName);
params.put("applicationName", applicationName);

HttpEntity<String> response = restOperations.exchange(
        urlTemplate,
        HttpMethod.GET,
        entity,
        String.class,
        params
);

-----------------------------------------------
approach 2
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(new DefaultUriBuilderFactory("http://localhost:8080"));
restTemplate.getForObject("/myservice", String.class);

Custom HTTP Header with the HttpClient

//commmon
HttpClient client = HttpClients.custom().build();
HttpClient client = HttpClients.custom().setDefaultHeaders(headers).build();
HttpClient client = new DefaultHttpClient();


way 1:
HttpUriRequest request = RequestBuilder.get()
  .setUri(SAMPLE_URL)
  .setHeader(HttpHeaders.CONTENT_TYPE, "application/json")
  .build();

way 2:
  HttpGet request = new HttpGet(SAMPLE_URL);
request.setHeader(HttpHeaders.CONTENT_TYPE, "application/json");

Header header = new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json");
List<Header> headers = Lists.newArrayList(header);
HttpClient client = HttpClients.custom().setDefaultHeaders(headers).build();


client.execute(request);


way of performing HTTP requests in Java

The HttpUrlConnection class allows us to perform basic HTTP requests without the use of any additional libraries. All the classes that we need are part of the java.net package.

Creating a Request
We can create an HttpUrlConnection instance using the openConnection() method of the URL class. Note that this method only creates a connection object but doesn't establish the connection yet.

The HttpUrlConnection class is used for all types of requests by setting the requestMethod attribute to one of the values: GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE.

Let's create a connection to a given URL using GET method:

//syncronous connection
URL url = new URL("http://example.com");
HttpURLConnection con = (HttpURLConnection) url.openConnection();
con.setRequestMethod("GET");


con.setRequestProperty("Content-Type", "application/json");

Connection timeout
con.setConnectTimeout(5000);
con.setReadTimeout(5000);


Q40) Spring annotation:

Rest EndPoint”
@SpringBootApplciation,@RestController,@Requestmapping,pathvariable,@RequestBody

PeriodicTasks
@Scheduled,@EnableScheduling,@Configuration,@Bean

SpringManagedComponent
@Confgiuration,@Valdiation,@Service, @Repository

Persistence
@Entity,@Id,@genratevalue,@EnableJpaRespositiores,@EnableTransactionmanagement

Micelinous:
@Autowired,@Inject,@Qualifier,@Resource,@ConfigurationProeprties

Testing @SpringBootTest @AutoConfigureMockMvc


Q41) Difference between @Controller &RestController

Q42) Difference between @Resource & Configuration properties
@ConfigurationProperties is used to map properties with POJO beans. Then you could use bean to access the properties values in your application.
@PropertySource is to reference a properties file and load it.
@Value is to inject a particular property value by it's key.

@Value("${spring.application.name}") @Value will throw exception if there no matching key in application.properties/yml file. It strictly injects property value.

@ConfigurationProperties(prefix = "myserver.allvalues") injects POJO properties, it's not strict, it ignores the property if there is no key in properties file.




Q43 ) what is difference between yml & app.propeties

Its usage is quite prevalent in many languages like Python, Ruby, and Java
It is primarily used in java
Hierarchical Structure
Non-Hierarchical Structure
Spring Framework doesn’t support @PropertySources with .yml files
supports @PropertySources with .properties file
If you are using spring profiles, you can have multiple profiles in one single .yml file
Each profile need one separate .properties file
While retrieving the values from .yml file we get the value as whatever the respective type (int, string etc.) is in the configuration
While in case of the .properties files we get strings regardless of what the actual value type is in the configuration




OAuth & OpenId connect

https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a


Open Authorisation is standard protocol for delagating authorisation.
It allows apps to access user data without user name password

OAuth 2.0
4 important c/p
1)Resource Owner ( user who owns the data that client want to access )
 /Client /
 Authorisation server ( authorisation server authorises the client to access a user’s data by granting permissions from user )
/Resource server  ( system that holds the user data )
/Access tokens token used for grant permission

User opens apps & apps want to access user profile/contact & then client request ask for authorisation grants & then server will ask user to provide grants ( allow or deny ) & when client do login & consent autgizationCode will be shared with the client & now client will use the auth code to connect to resource server to get the resource ( well resource server will al validate token with auth server to double check the client & code )

When client send auth request to auth server
Request will have
Response type
Scope ( what client want to access )
cleant_id ( setup at auth service to identify client )
Redirectui / callbackuri ( where to go once auth flow is complete )
client_secret

If browser based client is there then client server take the auth code and again query with auth server to get token

Oauth2.0 autharizes & delegate the auth but it did not identify/valdiated the user

And for that OpenID connect is used
Its an identity layer top of Auth 2.0 protocol

OpenIDConnect enables the client to identify the user based on auth performed by auth server
This is achieved by scope called open_id

open_id is mandatory scope to tell auth server that openID connect is required
Eg: url / response_type=code&client_id=ypur+client&scope=opeid%contacts&redirecturi-

The result of the request is application code that the client can exchange for access token & id token if auth flow is implicit then auth server reponds with accesstoekn & id token rightway

The id token is JWT or JSON web token. A JWT is encoded token that consists of 3 parts header payload & signature
And the user can decode id token to get user Info




Hibernate disadvantage
Might be bit slower than jdbc


Hibernate persist & save method
Difference depend upon the id generator class we are using
If generator class is assigned then there is no difference since we will give the primary id

If its Increment then hibernate assign the primary key id into db right & so save will give the primary key & press won’t give you the primary key

Hibernate different state of entity



Hibernate difference between update & merge

Both are used to convert object which is in detacehed state into pursuance state




Hibernate life cycle

In Hibernate , either we create an object of an entity & save it into db or we fetch data from an entity from db . So each entity object pass through a life cycle

1) Transient
2) Persistent
3) Detached

If we call get()/load() we will directly get persistent entity attached with session

If we create a new entity then it will be in transient state & when we call save/persist/saveOrUpdate()/update() transient state will convert to Persistent state

And when we call detach/close/clear/evict on Persistent it make it to Detached state

And when we call delete on persistent entity it will make it to transient


Detached to Persistence can be done by save/saveOrUpdate/metge/lock


EntityManagerFactory (1)-> (*) EntityManager (1) -> 1()Transaction Manager( Platform txnManager )
Every repo will have it 1 entity maanger class & 1 transaction mgr class asscoaited

Jdbc template method:
 template.query()
 template.queryForList()
 template.queryForObject()

         return jdbcTemplate.query(
                 sql,
                 (rs, rowNum) ->
                         new Customer(
                                 rs.getLong("id"),
                                 rs.getString("name"),
                                 rs.getInt("age"),
                                 rs.getTimestamp("created_date").toLocalDateTime()
                         )
         );







𝐒𝐩𝐫𝐢𝐧𝐠 𝐁𝐨𝐨𝐭 𝐀𝐜𝐭𝐮𝐚𝐭𝐨𝐫 - 𝐂𝐮𝐬𝐭𝐨𝐦 𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭𝐬

🟥𝐒𝐩𝐫𝐢𝐧𝐠 𝐁𝐨𝐨𝐭 𝐀𝐜𝐭𝐮𝐚𝐭𝐨𝐫 is the most important Spring sub-project required when we are deploying our
Spring Boot application to production because it brings support out of the box to monitor and manage our application.

Basically is the same thing as creating a @𝐑𝐞𝐬𝐭𝐂𝐨𝐧𝐭𝐫𝐨𝐥𝐥𝐞𝐫, but with different annotations, and the web requests are delivered through the /𝐚𝐜𝐭𝐮𝐚𝐭𝐨𝐫/𝐞𝐧𝐝𝐩𝐨𝐢𝐧𝐭-𝐢𝐝 path.

➡️In Spring Boot 2 we can do that using @𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭 annotation which combines the power of JMX(@𝐉𝐦𝐱𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭) and Web(@𝐖𝐞𝐛𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭) technologies.

➡️Using @𝐉𝐦𝐱𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭 instead of @𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭 will make your endpoint available only for JMX calls, and @𝐖𝐞𝐛𝐄𝐧𝐝𝐩𝐨𝐢𝐧𝐭 will make your endpoint only through web calls.

➡️Through this actuator endpoint you have the possibility to send read(@𝐑𝐞𝐚𝐝𝐎𝐩𝐞𝐫𝐚𝐭𝐢𝐨𝐧), write(@𝐖𝐫𝐢𝐭𝐞𝐎𝐩𝐞𝐫𝐚𝐭𝐢𝐨𝐧), and delete(@𝐃𝐞𝐥𝐞𝐭𝐞𝐎𝐩𝐞𝐫𝐚𝐭𝐢𝐨𝐧) requests.



How & what is the fasted way to update 1M records in db ?
This is absolutely a viable approach, and one we have used repeatedly. One of our apps updates a table of several hundred million records.

The cursor..For loop approach for the update was calculated to take 53.7 years to complete!
We institued the Insert into a dummy table append with nologging, and were able to complete the "update" in under 30 minutes.

With nologging, if the system aborts, you simply re-run the 'update' again, as you have the original data in the main table. When done, we swap the partition of original data with the 'dummy' table (the one containing new values), rebuild indexes in parallel, and wha-la! Our update is complete.

i.e, to update field2 in a table:

1) First create your dummy hold table: create table xyz_HOLD as select * from xyz where rownum<1. Alter tablexyz nologging.

2) insert /*+ append parallel (xyzhold,12) */ into xyz_hold xyzhold (field1, field2, field3) select /*+ parallel (x,12) */ xyz.field1, my_new_value_for_field2, xyz.field3 from xyz x where blah blah blah.

3) when done, either rename the table, or swap the partition if your original table is partitioned, and you only updated one partition as we do. Obviously you need to rebuild indecies, etc as required.

Hope this helps!


How to persist the information in the database as fast as possible (without losing data of course),
and in particular, to persist new information (INSERT), not to update it (UPDATE).


JPA /Hibernate

A register each time
EntityTransaction tx = entityManager.getTransaction();
Iterator<TripEntity> iterator = trips.iterator();
while (iterator.hasNext()) {
    tx.begin();
    entityManager.persist(iterator.next());
    tx.commit();
}

Improved version:
 A register each time in transactions of 1000 elements

 EntityTransaction tx = entityManager.getTransaction();
 Iterator<TripEntity> iterator = trips.iterator();
 tx.begin();
 int cont = 0;
 while (iterator.hasNext()) {
     entityManager.persist(iterator.next());
     cont++;
     if (cont % batchSize == 0) {
         tx.commit();
         tx.begin();
     }
 }
 tx.commit();


3.- Flush
By the way Hibernate works (and the rest of JPA implementations), to do all its magic you need to track all the entities that go through it. All these entities are managed by the EntityManager, maintaining the uniqueness of instances, their status, and their life cycle.

The more records you persist, the more entities end up in the EntityManager, the more memory they consume and the more objects it has to manage when doing certain operations. One of them is the flush, and JPA executes it, for example, every time we execute a commit.

Therefore, if you are going to persist many records, you will not be interested in having them all in context, and you will be able to clean them up often, by explicitly executing the flush and clear operations from EntityManager.

EntityTransaction tx = entityManager.getTransaction();
Iterator<TripEntity> iterator = trips.iterator();
tx.begin();
int cont = 0;
while (iterator.hasNext()) {
    entityManager.persist(iterator.next());
    cont++;
    if (cont % batchSize == 0) {
        entityManager.flush();
        entityManager.clear();
        tx.commit();
        tx.begin();
    }
}
tx.commit();

4.- In batches of 1000 records

EntityManagerFactoryFactory factory = new EntityManagerFactoryFactory(dsFactory, TripEntity.class) {
    @Override
    public Properties properties() {
        Properties properties = super.properties();
        properties.put("hibernate.jdbc.batch_size", batchSize);
        return properties;
    }
};

good Link : https://medium.com/@jerolba/persisting-fast-in-database-1af4a281e3a


HIbernete ( ORM reltional mapping )

how does hibenrete do query in databse

HQL based / repository based
String hql = "FROM com.hibernatebook.criteria.Employee";
Query query = session.createQuery(hql);
List results = query.list();

https://www.tutorialspoint.com/hibernate/hibernate_query_language.htm

Spring based HIbernete
https://stackoverflow.com/questions/54507552/how-to-join-results-of-multiple-tables-in-spring-jpa-repository
https://www.petrikainulainen.net/programming/spring-framework/spring-data-jpa-tutorial-three-custom-queries-with-query-methods/

Hibernete Named Query
Creating Database Queries With Named Querie

Entity
@NamedNativeQuery(name = "Todo.findBySearchTermNamedNative",
        query="SELECT * FROM todos t WHERE " +
                "LOWER(t.title) LIKE LOWER(CONCAT('%',:searchTerm, '%')) OR " +
                "LOWER(t.description) LIKE LOWER(CONCAT('%',:searchTerm, '%'))",
        resultClass = Todo.class
)
@NamedQuery(name = "Todo.findBySearchTermNamed",
        query = "SELECT t FROM Todo t WHERE " +
                "LOWER(t.title) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
                "LOWER(t.description) LIKE LOWER(CONCAT('%', :searchTerm, '%'))"
)
@Table(name = "todos")
final class Todo {

}
Creating Database Queries With the @Query Annotation

interface TodoRepository extends Repository<Todo, Long> {

    @Query("SELECT t FROM Todo t WHERE t.title = 'title'")
    public List<Todo> findById();
}
Link : https://thorben-janssen.com/spring-data-jpa-query-annotation/

sorting the result
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("FROM Author WHERE firstName = ?1")
    List<Author> findByFirstName(String firstName, Sort sort);
}
//way 2
ort sort = new Sort(Direction.ASC, "firstName");
List<Author> authors = authorRepository.findByFirstName("Thorben", sort);

Pageable
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("FROM Author WHERE firstName = ?1")
    List<Author> findByFirstName(String firstName, Pageable pageable);
}
ageable pageable = PageRequest.of(0, 10);
List<Author> authors = authorRepository.findByFirstName("Thorben", pageable);

Defining a Custom Native Query
Similar to the custom JPQL query, you can use the @Query annotation to specify a custom native SQL query. But you need to tell Spring Data JPA, that you are defining a native query, so that it can execute the query in the right way. You can do that by setting the nativeQuery attribute of the @Query annotation to true.



Native Querries
https://thorben-janssen.com/jpa-native-queries/
Similar to the custom JPQL query, you can use the @Query annotation to specify a custom native SQL query. But you need to tell Spring Data JPA, that you are defining a native query, so that it can execute the query in the right way. You can do that by setting the nativeQuery attribute of the @Query annotation to true.

public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query(value = "SELECT * FROM author WHERE first_name = :firstName", nativeQuery = true)
    List<Author> findAuthorsByFirstName(@Param("firstName") String firstName);
}
The query that you provide as the value of the annotation will not be parsed or changed by your JPA implementation. It gets directly send to your database. So, you need to make sure that you provide a valid SQL statement and follow the specific dialect of your database.


Parameter Handling
To use both kinds of queries with Spring Data JPA, you need to be familiar with bind parameters. Bind parameters act as placeholders in your query for which you can set values before the query gets executes. They are regularly used in the WHERE clause of a query. You should always prefer them over inlining a parameter value because bind parameters:

prevent SQL injection vulnerabilities,
get automatically converted to the correct SQL type and
enable your persistence provider and database to optimize your query.
Spring Data JPA handles the bind parameters of JPQL and native SQL queries in the same way. For each query, you can choose if you want to use positional or named bind parameters.

Very Good link : https://thorben-janssen.com/spring-data-jpa-query-annotation/

Spring Data JPA provides multiple options to define a query on your repository interface. You can:

use derived queries for which Spring Data JPA generates the required query based on the name of the repository method. I explained that in great details in a previous tutorial.
use the @Query annotation to define your own query. That’s what we discussed in this article.
reference a named query which you specified on one of your entities. We will take a closer look at that in a future tutorial.
By using the @Query annotation, you get full control over the executed query. You can choose between a native SQL or a JPQL query. By default, Spring Data JPA expects that you provide a JPQL query. If you want to execute a native query, you need to set the nativeQuery parameter of the @Query annotation to true.

Both kinds of queries get processed by the underlying JPA implementation. That enables you to reuse all your Hibernate and EclipseLink knowledge and to use the query features supported by these frameworks.

You can also specify modifying queries which insert, update, or remove records from the database. Spring Data JPA needs to generate a slightly different JPA code for these. You, therefore, need to annotate repository methods that execute modifying queries with the @Modifying annotation.

PreparedStatement interface
The PreparedStatement interface is a subinterface of Statement. It is used to execute parameterized query.
Following are the advantages of the prepared statement:
Executing the Prepared Statement
Once you have created the PreparedStatement object you can execute it using one of the execute() methods of the PreparedStatement interface namely, execute(), executeUpdate() and, executeQuery().
execute(): This method executes normal static SQL statements in the current prepared statement object and returns a boolean value.
executeQuery(): This method executes the current prepared statement and returns a ResultSet object.
executeUpdate(): This method executes SQL DML statements such as insert update or delete in the current Prepared statement. It returns an integer value representing the number of rows affected.
By avoiding multiple compilation and execution of statements, prepared statements perform faster.
Using prepared statements, we can insert values to advanced datatypes such as BLOB, CLOB, OBJECT easily with the help of the setter methods provided by the PreparedStatement interface.
By providing setter method to set values prepared statement avoids the use of quotes and other special characters with in the query, and thereby it escapes the SQL injection attacks
Following are the limitations of prepared statements:
Since a PreparedStatement object represents only one SQL statement at a time, we can execute only one statement by one prepared statement object.
To prevent injection attacks it does not allow more than one value to a place holder.

Stored procedure type	JDBC method
Stored procedure requires no IN or OUT parameters	Use a Statement object
Stored procedure with IN parameters	Use a PreparedStatement object
Stored procedure with IN and OUT parameters	Use a CallableStatement object

Good link : https://developer.ibm.com/articles/dm-1209storedprocedures/


Hibernate is a JPA implementation, while Spring Data JPA is a JPA data access abstraction.
Spring Data JPA cannot work without a JPA provider.

JDBC is a low level standard for interaction with databases.
JPA is higher level standard for the same purpose.
 JPA allows you to use an object model in your application which can make your life much easier.
 JDBC allows you to do more things with the Database directly, but it requires more attention

As an object-oriented query language, it uses Java Persistence Query Language (JPQL) to execute database operations.

As an object-oriented query language, it uses Hibernate Query Language (HQL) to execute database operations.

To interconnect with the entity manager factory for the persistence unit, it uses EntityManagerFactory interface. Thus, it gives an entity manager.

To create Session instances, it uses SessionFactory interface.
To make, read, and remove actions for instances of mapped entity classes, it uses EntityManager interface. This interface interconnects with the persistence condition.

To make, read, and remove actions for instances of mapped entity classes, it uses Session interface. It acts as a runtime interface between a Java application and Hibernate.



APIs required to call a third party api from your service.
sometime restbased client & sometime its MQ communication

Do you know about Feign Client? Explain
client to call rest servicer from aother service
Spring restbased remplated anoother with @LoadBalanced can also be used for communication

Spring test

Junit
What are you using for mocking the rest template? Annotations used?
How do you Mock DB?





